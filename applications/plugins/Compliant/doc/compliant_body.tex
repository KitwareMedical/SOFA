\newcommand{\vect}[1]{\mathbf{#1}}
\newcommand{\mat}[1]{\mathbf{#1}}

\newcommand{\pos}{\vect{x}}
\newcommand{\dx}{\vect{\Delta x}}
\newcommand{\xcur}{\vect{x}_{n}}
\newcommand{\xnext}{\vect{x}_{n+1}}
\newcommand{\vel}{\vect{v}}
\newcommand{\dv}{\vect{\Delta v}}
\newcommand{\vcur}{\vect{v}_{n}}
\newcommand{\vnext}{\vect v_{n+1}}
\newcommand{\acc}{\vect{a}}
\newcommand{\force}{\vect{f}}
\newcommand{\forcext}{\vect{f}_{ext}}
\newcommand{\lam}{\vect{\lambda}}
\newcommand{\lcur}{\lam_{n}}
\newcommand{\lnext}{\lam_{n+1}}
\newcommand{\avlam}{\bar{\lam}}
\newcommand{\fcur}{\vect{f}_{n}}
\newcommand{\fnext}{\vect f_{n+1}}
\newcommand{\M}{\mat M}
\newcommand{\Minv}{\mat M^{-1}}
\renewcommand{\P}{\mat P}
\newcommand{\J}{\mat J}
\newcommand{\Jt}{\mat J^T}
\newcommand{\C}{\mat C}
\newcommand{\violation}{ \phi}
\newcommand{\dviolation}{\dot \violation}
\newcommand{\violcur}{\violation_{n}}
\newcommand{\violnext}{\violation_{n+1}}
\newcommand{\dviolnext}{\dot \violation_{n+1}}
\newcommand{\cmp}{c}
\newcommand{\dampingratio}{d}

\section{Constraint forces}
This approach unifies soft and hard constraints. Hard constraints are usually implemented using Lagrange multipliers $\lambda$ in the following equation:
\begin{equation} \label{eq acc hard}
\left( \begin{array}{cc}
\M & -\Jt \\
 \J &  \end{array}\right)
\left( \begin{array}{c}
\acc \\ \lam
\end{array}\right) = \left( \begin{array}{c}
\forcext  \\
-\violation
\end{array}\right) 
\end{equation}
where $\M$ is the mass matrix, $\J$ is the Jacobian matrix of the constraint(s), $\acc$ is the acceleration, $\forcext$ is the net external force applied to the system, $\lam$ is the constraint force and $\violation$ is the constraint violation.
$\lam$ and $\violation$ are vectors with as many entries as scalar constraints. The equation system is typically solved using a Schur complement to compute the constraint forces:
\begin{equation}\label{eq schur rigid}
\J \Minv \Jt \lam = -\violation - \J \Minv \forcext
\end{equation}
and then the acceleration is computed as $\acc = \Minv( \forcext + \Jt \lam)$.


In the generalized approach, the constraint forces are considered proportional to the constraint violations:
\begin{equation}\label{eq generalized constraint}
\lam = - \frac{1}{\cmp} \left( \violation + \dampingratio \dviolation \right)
\end{equation}
where the positive real number $\cmp$ is the compliance of the constraint and $\dampingratio$ is its damping ratio.
Combined with a time discretization scheme, this leads to an equation system similar to \eqref{eq schur rigid} as shown is the next section.
% This leads to equation system:
% \begin{equation} \label{eq acc compliant}
% \left( \begin{array}{cc}
% \M & -\Jt \\
%  \J &  \C \end{array}\right)
% \left( \begin{array}{c}
% \acc \\ \lam
% \end{array}\right) = \left( \begin{array}{c}
% \forcext  \\
% -\violation - \dampingratio \dviolation
% \end{array}\right) 
% \end{equation}
% where $\C$ is the compliance matrix, typically diagonal, which is null for hard constraints. The corresponding Schur complement is well-conditioned for hard constraints:
% \begin{equation}\label{eq schur compliant}
% \left( \J \Minv \Jt  +   \C \right) \lam = -\violation - \dampingratio\dviolation - \J \Minv \forcext
% \end{equation}
% contrary to the standard implicit integration approach, where the indefinite stiffness matrix grows to infinity for hard constraints.


\section{Time integration}
Our implicit scheme is:
\begin{eqnarray}
 \vnext &=& \vcur + h \Minv \left(\alpha \fnext + (1-\alpha) \fcur\right) \\
  \xnext &=& \xcur + h \left( \beta \vnext + (1-\beta) \vcur \right)
\end{eqnarray}
where index $n$ denotes current values while index $n+1$ denotes next values, $\alpha$ is the implicit velocity factor, and $\beta$ is the implicit position factor. Let
\begin{eqnarray}
 \dv = \vnext -    \vcur  &=& h \Minv \left(\alpha \fnext + (1-\alpha) \fcur\right) \\
\dx = \xnext -  \xcur    &=& h (v + \beta  \dv)
\end{eqnarray}
be the velocity and position changes across the time step.
The constraint violation $\violation$ and its Jacobian $\J$ are:
\begin{eqnarray}
 \J &=& \frac{\partial \vect \violation}{\partial \pos} \\
 \violnext &\simeq& \violcur + \J \dx = \violcur + h   \dviolation + \J h \beta \Delta \vel  \label{eq violnext}\\
\dviolnext &\simeq& \violnext + \J \dv \label{eq dviolnext}
\end{eqnarray}
The corresponding forces are:
\begin{eqnarray}
 \force &=& \forcext + \Jt \lam \\
 \lam_i &=& -\frac{1}{c_i} (  \violation_i + d \dviolation_i ) \label{eq lambda}
\end{eqnarray}
where the subscript $i$ denotes a scalar constraint.

The average constraint forces are computed  using equations \ref{eq lambda}, \ref{eq violnext} and \ref{eq dviolnext}:
\begin{eqnarray*}
 \avlam_i &=& \alpha \lnext + (1-\alpha) \lcur \\
&=& -\frac{1}{c_i} ( \alpha \violation + \alpha h \dviolation  + \alpha h \beta \J \Delta \vel + \alpha d \dviolation + \alpha d \J \dv + (1-\alpha)\violation + (1-\alpha) d \dviolation  ) \\
&=& -\frac{1}{c_i} ( \violation + d\dviolation + \alpha h \dviolation + \alpha(h\beta+d)\J \dv )
\end{eqnarray*}
We can rewrite the previous equation as:
\begin{equation}
 \J \dv + \frac{1}{\alpha(h\beta+d)}\C\avlam = - \frac{1}{\alpha(h\beta+d)} (\violation + (d+\alpha h)\dviolation)
\end{equation}
where values without indices denote current values.
The complete equation system is:
\begin{equation}
 \left( \begin{array}{cc}
\frac{1}{h}\P\M & -\P\Jt \\
\J & \frac{1}{l} \C \end{array}\right)
\left( \begin{array}{c}
\dv \\ \avlam
\end{array}\right) = \left( \begin{array}{c}
\P\forcext  \\
- \frac{1}{l} (\violation +(d+\alpha h) \dviolation)
\end{array}\right) 
\end{equation}
where $ l=\alpha(h \beta + d) $
The system is singular due to matrix $\P $, however we can use $ \P \Minv\P $ as inverse mass matrix to compute a Schur complement:
\[ \begin{array}{ccc}
\left( h\J\P\Minv\P\Jt + \frac{1}{l}\C \right) \avlam &=& -\frac{1}{l} \left(\violation + (\dampingratio+h\alpha)\dviolation \right) - h\J \Minv \forcext \\
\dv &=& h\P\Minv(\forcext +\Jt \avlam ) \\
\dx &=& h( \vel + \beta \dv )
\end{array} \]


\section{Matrix assembly}
The equation system, in its most general form, can be written as:
\begin{equation}
 \label{eq abstract system}
 \left( \begin{array}{cc}
\M & -\Jt \\
\J &  \C \end{array}\right)
\left( \begin{array}{c}
\pos \\ \lam
\end{array}\right) = \left( \begin{array}{c}
\force  \\
\violation
\end{array}\right) 
\end{equation}
We assemble the $7$ terms of equation~\ref{eq abstract system} separately. 

Figure~\ref{fig system graph} shows an example of mechanical system.
The independent DOFs are $X_{a}$ and $X_d$.
State $X_b$ is attached to $X_a$ using a simple mapping, and a mass matrix $M_{bb}$ is defined at this level.
State $X_c$ is attached to $X_b$ using a simple mapping, and a compliance matrix $C_{\alpha \alpha}$ (possibly a deformation force) is applied to these DOFs.
State $X_e$ is attached to $X_a$ and  $X_d$ at the same time, using a MultiMapping. A compliance matrix $C_{\beta \beta}$, possibly an interaction force, is applied to these DOFs, 
while a mass $M_{dd}$ is applied to $X_d$.
\begin{figure}
\centering
 \includegraphics[width=0.49\linewidth]{system-graph.png}
\caption{A mechanical system. The $X$ represent mechanical states, while the arrows represent the kinematic hierarchy, and the plain lines represent components acting on the states.}
\label{fig system graph}
\end{figure}


The corresponding equation system has the block structure shown in the right of Figure~\ref{fig system matrix}.
The main blocks of the equation system are highlighted in grey rectangles. The $J$ matrices are the mapping matrices. The bottom row has two mappings, since the state $X_e$ impacted by compliance $\beta$ depends on two parent states.
\begin{figure}
\centering
 \includegraphics[width=0.7\linewidth]{system-bigmatrix.png}
\caption{Block view of the equation~\ref{eq abstract system} applied to the system of Figure~\ref{fig system graph}, with non-null blocks highlighted in yellow.}
\label{fig system matrix}
\end{figure}


The assembly of local matrices and vectors to the global matrices and vectors which compose the system is performed using shift matrices, as illustrated in Figure~\ref{fig shifting}.
Shift matrices $J_{*0}$, shown in the top of the figure, are composed of identity matrices (represented with a diagonal in a block) and null blocks. They can be used to implement the shifting of vector entry indices from local to global. 
\begin{figure}
\centering
 \includegraphics[width=0.69\linewidth]{system-shift.png}
\label{fig shifting}
\caption{Shift matrices $J_{*0}$ are used to place blocks within global vectors and matrices. }
\end{figure}
The assembly is thus easily expressed as a sum of product of matrices, as illustrated in Figure~\ref{fig assembly}. 
While shifting values in dense arrays using matrix products is not efficient (vector assembly is actually implemented using shifted copies), the sum of matrix products is a reasonable implementation of sparse matrix assembly.
\begin{figure}
\centering
 \includegraphics[width=0.6\linewidth]{system-assembly.png}
\caption{The assembly is performed by summing the global vectors and matrices obtained by shifting local vectors and matrices.}
\label{fig assembly}
\end{figure}

