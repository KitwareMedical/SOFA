/******************************************************************************
*       SOFA, Simulation Open-Framework Architecture, version 1.0 RC 1        *
*                (c) 2006-2011 MGH, INRIA, USTL, UJF, CNRS                    *
*                                                                             *
* This library is free software; you can redistribute it and/or modify it     *
* under the terms of the GNU Lesser General Public License as published by    *
* the Free Software Foundation; either version 2.1 of the License, or (at     *
* your option) any later version.                                             *
*                                                                             *
* This library is distributed in the hope that it will be useful, but WITHOUT *
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or       *
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License *
* for more details.                                                           *
*                                                                             *
* You should have received a copy of the GNU Lesser General Public License    *
* along with this library; if not, write to the Free Software Foundation,     *
* Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.          *
*******************************************************************************
*                               SOFA :: Plugins                               *
*                                                                             *
* Authors: The SOFA Team and external contributors (see Authors.txt)          *
*                                                                             *
* Contact information: contact@sofa-framework.org                             *
******************************************************************************/
#ifndef SOFA_COMPONENT_LOADER_VOXELIZER_H
#define SOFA_COMPONENT_LOADER_VOXELIZER_H

#include <sofa/core/loader/MeshLoader.h>
#include "initVoxelizer.h"
#include <sofa/gpu/cuda/CudaRasterizer.h>
#include <sofa/helper/vector.h>
#include <string>
#include <map>
#include <sofa/defaulttype/Vec.h>
#include <sofa/core/objectmodel/BaseNode.h>



namespace sofa
{

namespace helper
{

namespace io
{

class ImageRAW;

}

}

namespace component
{

namespace loader
{

using std::string;
using sofa::helper::vector;
using sofa::defaulttype::Vec3d;
using sofa::core::objectmodel::Tag;
using sofa::core::objectmodel::TagSet;
using sofa::core::loader::MeshLoader;
using sofa::core::objectmodel::BaseContext;
using sofa::core::objectmodel::BaseNode;
using sofa::core::objectmodel::BaseObject;

/** class Voxelizer
 * This component allows to generate RAW files from the analysis of the LDI structures generated by the Rasterizer component.
 *
 * --- Use ---
 * Needed:
 * triangularModelPath: contains the list of topology containers to be rasterized to generrate the RAW file. A path set to NULL rasterize the empty space, outside of the models.
 * voxelSize: describes the wanted size of voxels.
 *
 * Options:
 * useROI: can be specified to use spherical ROIs defined by vROICenter and vROIRadius.
 * bbox: set the volume of rasterization. The default volume is the minimal bounding box containing all the objects.
 * generateRAWFiles: the RAW files generation can be avoided to only exploit the rasterized volumes.
 *
 * Result:
 * valueFileName (containing 0/255 values), segmentationFileName(containing labels of the different models equal to the index of the model in triangularModelPath)
 * and infoFileName (containing the voxel size, the raw origin and the resolution) are generated
 *
 * --- Visu ---
 * the rasterized volumes structure and their visualization can be achieved only if the RAW files do not exist..
*/
template <class DataTypes>
class SOFA_VOXELIZER_API Voxelizer : public MeshLoader
{
public:
    SOFA_CLASS( SOFA_TEMPLATE ( Voxelizer, DataTypes) ,MeshLoader);

    typedef gpu::cuda::CudaRasterizer<DataTypes> Rasterizer;
    typedef typename Rasterizer::CellCountLayer CellCountLayer;
    typedef typename Rasterizer::Cell Cell;
    typedef typename Rasterizer::LDI LDI;

    typedef sofa::core::topology::BaseMeshTopology MTopology;
    typedef typename defaulttype::Vec3f FPoint;
    typedef typename helper::fixed_array<FPoint, 2> BBox;
    typedef typename DataTypes::Real Real;
    typedef std::multimap< double, std::multimap<double, std::pair< double, double> > > RasterizedVol; // map< x, map< y, pair< zMin, zMax> > >

    // ROI
    Data<bool> useROI; // Spherical regions of interest can be specified.
    Data<vector<Vec3d> > vROICenter; // Center of the ROIs
    Data<vector<double> > vROIRadius; // Radius of the ROIs

    // Global volume
    Data<BBox> boundingBox; // if not useROI, a rasterization bounding box can be specified. The default bounding box is defined by the rasterized objects

    // Rasterized Objects
    Data<string> triangularModelPath;
    Data<Vec3d> voxelSize;

    // Generated files
    Data<bool> generateRAWFiles;
    Data<string> valueFileName;
    Data<string> segmentationFileName;
    Data<string> infoFileName;
    Data<Vec3d> rawOrigin; // MechObj can connect their "position" Data on this one.
    Data<Vec3d> resolution;

    // Visualization options
    Data<bool> showRasterizedVolumes;
    Data<bool> showWireFrameMode;
    Data<unsigned int> showWhichAxis;

    Voxelizer();
    ~Voxelizer();

    virtual void init();

    RasterizedVol** getRasterizedVolumes() const;

    virtual void draw();

    virtual bool canLoad();
    virtual bool load();
    virtual bool createImages (RasterizedVol** rasterizedVolume); // rasterizedVolume array indexed following: axis and triangularModel

    template <class T>
    static bool canCreate ( T*& obj, core::objectmodel::BaseContext* context, core::objectmodel::BaseObjectDescription* arg );

protected:
    Rasterizer* rasterizer;
    vector<MTopology*> vTriangularModel;
    vector<bool> hadSelfCollisionTag;

    // Initial rasterizer settings
    TagSet rasterizerTags;
    double rasterizerPixelSize;
    BBox rasterizerBBox;
    RasterizedVol** rasterizedVolumes;

    helper::io::ImageRAW* valueImg;
    helper::io::ImageRAW* segmentationImg;

    inline void addVolume( RasterizedVol& rasterizedVolume, double x, double y, double zMin, double zMax, int axis);
    inline void generateFullVolumes( RasterizedVol** rasterizedVolume);
    inline bool isCoordInside( const Vec3d& position, const RasterizedVol& rasterizedVolume, const unsigned int axis); // return true if pos is in the rasterizedVolume.
    inline unsigned int isCoordInside( const Vec3d& position, const RasterizedVol* rasterizedVolume, const unsigned int axis); // return the rasterizeVolume index in which pos is present.
    inline bool isCoordInside( const BBox& boundingBox, const RasterizedVol& rasterizedVolume, const unsigned int axis); // return true if pos is in the rasterizedVolume.
    inline unsigned int isCoordInside( const BBox& boundingBox, const RasterizedVol** rasterizedVolume); // return the rasterizeVolume index in which pos is present.
    inline unsigned int isCoordInside( const BBox& boundingBox, const RasterizedVol* rasterizedVolume, const unsigned int axis); // return the rasterizeVolume index in which pos is present.
    inline bool isCoordIntersecting( const BBox& boundingBox, const RasterizedVol& rasterizedVolume, const unsigned int axis); // return true if pos intersect the rasterizedVolume.
    inline unsigned int isCoordIntersecting( const BBox& boundingBox, const RasterizedVol** rasterizedVolume); // return the rasterizeVolume index intersecting bbox.
    inline unsigned int isCoordIntersecting( const BBox& boundingBox, const RasterizedVol* rasterizedVolume, const unsigned int axis); // return the rasterizeVolume index intersecting bbox.
    void temporaryChangeTags();
    void restoreTags();
    template<class T>
    T* findObject( string path, const BaseContext* context);
    bool saveRAW( const std::string filename, const unsigned char* data, const unsigned int size) const;
    void saveInfos();
    void loadInfos();
    inline void changeRasterizerSettings();
    inline void reloadRasterizerSettings();
};

#if defined(SOFA_EXTERN_TEMPLATE) && !defined(SOFA_BUILD_VOXELIZER)
#ifndef SOFA_FLOAT
extern template class Voxelizer<defaulttype::Vec3dTypes>;
#endif
#ifndef SOFA_DOUBLE
#endif
#endif



} // namespace loader

} // namespace component

} // namespace sofa

#endif
