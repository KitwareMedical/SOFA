format 73
"behavior" // sofa::core::behavior
  revision 3
  modified_by 48 "allardj"
  // class settings
  //class diagram settings
  draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
  //use case diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default class_drawing_mode default shadow default show_stereotype_properties default
  //sequence diagram settings
  show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default
  //collaboration diagram settings
  show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default draw_all_relations default shadow default show_stereotype_properties default
  //object diagram settings
   write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
  //component diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //deployment diagram settings
  package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //state diagram settings
  package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
  show_activities default region_horizontally default drawing_language default show_stereotype_properties default
  //activity diagram settings
  package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
  show_infonote default drawing_language default show_stereotype_properties default
  
  cpp_h_dir "/home/allardj/work/Sofa/framework/sofa/core/behavior/"
  cpp_src_dir "/home/allardj/work/Sofa/framework/sofa/core/behavior/"
  cpp_namespace "sofa::core::behavior"
  classview 128432 "behavior"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    class 147632 "ConstraintResolution"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Object computing a constraint resolution within a Gauss-Seidel algorithm"
      operation 181680 "ConstraintResolution"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} : nbLines(1), tolerance(0.0) {};
"
	
	
	
	
      end

      operation 181808 "~ConstraintResolution"
	cpp_virtual cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {};
"
	
	
	
	
      end

      operation 181936 "init"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 3
	  param in name "" explicit_type "int"
	  param inout name "" explicit_type "double"
	  param inout name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ The resolution object can do precomputation with the compliance matrix, and give an initial guess."
      end

      operation 182064 "initForce"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "" explicit_type "int"
	  param inout name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ The resolution object can provide an initial guess"
      end

      operation 182192 "resolution"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 5
	  param in name "line" explicit_type "int"
	  param inout name "w" explicit_type "double"
	  param inout name "d" explicit_type "double"
	  param inout name "force" explicit_type "double"
	  param inout name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * * ${p1}${v1}, ${t2} * ${p2}${v2}, ${t3} * ${p3}${v3}, ${t4} * ${p4}${v4}${)}${const}${volatile}${throw}${abstract} {
		resolution(line, w, d, force);
	};
"
	
	
	
	
	comment "/ Resolution of the constraint for one Gauss-Seidel iteration"
      end

      operation 182320 "resolution"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 4
	  param in name "" explicit_type "int"
	  param inout name "" explicit_type "double"
	  param inout name "" explicit_type "double"
	  param inout name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * * ${p1}${v1}, ${t2} * ${p2}${v2}, ${t3} * ${p3}${v3}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ Resolution of the constraint for one Gauss-Seidel iteration
/ @deprecated"
      end

      operation 182448 "store"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 3
	  param in name "" explicit_type "int"
	  param inout name "" explicit_type "double"
	  param in name "" explicit_type "bool"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ Called after Gauss-Seidel last iteration, in order to store last computed forces for the inital guess"
      end

      attribute 139056 "nbLines"
	public explicit_type "byte"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 139184 "tolerance"
	public explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 147760 "BaseConstraint"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component computing constraints within a simulated body.
 *
 *  This class define the abstract API common to all constraints.
 *  A BaseConstraint computes constraints applied to one or more simulated body
 *  given its current position and velocity.
 *
 *  Constraints can be internal to a given body (attached to one MechanicalState,
 *  see the Constraint class), or link several bodies together (such as contacts,
 *  see the InteractionConstraint class).
 *"
      classrelation 140080 // <generalisation>
	relation 140080 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 140080 // <generalisation>
	  b parent class_ref 147888 // BaseConstraintSet
      end

      operation 182576 "~BaseConstraint"
	cpp_virtual cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} { };
"
	
	
	
	
      end

      operation 182704 "getGroup"
	const cpp_inline public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return group.getValue(); };
"
	
	
	
	
	comment "/ Get the ID of the group containing this constraint. This ID is used to specify which constraints are solved by which solver, by specifying in each solver which groups of constraints it should handle."
      end

      operation 182832 "setGroup"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "g" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { group.setValue(g); };
"
	
	
	
	
	comment "/ Set the ID of the group containing this constraint. This ID is used to specify which constraints are solved by which solver, by specifying in each solver which groups of constraints it should handle."
      end

      class 148016 "PersistentID"
	visibility package stereotype "typedef" explicit_base_type "long long"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 148144 "VecPersistentID"
	visibility package stereotype "typedef" base_type class_ref 148016 // PersistentID
	cpp_decl "${comment}typedef helper::vector<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 140208 // <dependency>
	  relation 140208 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 140208 // <dependency>
	    b parent class_ref 148016 // PersistentID
	end
      end

      class 148272 "ConstCoord"
	visibility package stereotype "typedef" explicit_base_type "defaulttype::Vec<3,int>"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 148400 "VecConstCoord"
	visibility package stereotype "typedef" base_type class_ref 148272 // ConstCoord
	cpp_decl "${comment}typedef helper::vector<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 140336 // <dependency>
	  relation 140336 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 140336 // <dependency>
	    b parent class_ref 148272 // ConstCoord
	end
      end

      class 148528 "ConstDeriv"
	visibility package stereotype "typedef" explicit_base_type "defaulttype::Vec<3,double>"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 148656 "VecConstDeriv"
	visibility package stereotype "typedef" base_type class_ref 148528 // ConstDeriv
	cpp_decl "${comment}typedef helper::vector<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 140464 // <dependency>
	  relation 140464 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 140464 // <dependency>
	    b parent class_ref 148528 // ConstDeriv
	end
      end

      class 148784 "ConstArea"
	visibility package stereotype "typedef" explicit_base_type "double"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 148912 "VecConstArea"
	visibility package stereotype "typedef" base_type class_ref 148784 // ConstArea
	cpp_decl "${comment}typedef helper::vector<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 140592 // <dependency>
	  relation 140592 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 140592 // <dependency>
	    b parent class_ref 148784 // ConstArea
	end
      end

      class 149040 "ConstraintBlockInfo"
	visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 140720 // parent (<unidirectional association>)
	  relation 140720 --->
	    a role_name "parent" public
	      cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      classrelation_ref 140720 // parent (<unidirectional association>)
	    b parent class_ref 147760 // BaseConstraint
	end

	attribute 139312 "const0"
	  public explicit_type "int"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "/< index of first constraint"
	end

	attribute 139440 "nbLines"
	  public explicit_type "int"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "/< how many dofs (i.e. lines in the matrix) are used by each constraint"
	end

	attribute 139568 "nbGroups"
	  public explicit_type "int"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "/< how many groups of constraints are active"
	end

	attribute 139696 "hasId"
	  public explicit_type "bool"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "/< true if this constraint has persistent ID information"
	end

	attribute 139824 "hasPosition"
	  public explicit_type "bool"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "/< true if this constraint has coordinates information"
	end

	attribute 139952 "hasDirection"
	  public explicit_type "bool"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "/< true if this constraint has direction information"
	end

	attribute 140080 "hasArea"
	  public explicit_type "bool"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "/< true if this constraint has area information"
	end

	attribute 140208 "offsetId"
	  public explicit_type "int"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "/< index of first constraint group info in vector of persistent ids and coordinates"
	end

	attribute 140336 "offsetPosition"
	  public explicit_type "int"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "/< index of first constraint group info in vector of coordinates"
	end

	attribute 140464 "offsetDirection"
	  public explicit_type "int"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "/< index of first constraint info in vector of directions"
	end

	attribute 140592 "offsetArea"
	  public explicit_type "int"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "/< index of first constraint group info in vector of areas"
	end

	operation 182960 "ConstraintBlockInfo"
	  cpp_inline public explicit_return_type ""
	  nparams 0
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} : parent(NULL), const0(0), nbLines(1), nbGroups(0), hasId(false), hasPosition(false), hasDirection(false), hasArea(false), offsetId(0), offsetPosition(0), offsetDirection(0), offsetArea(0)
        {};
"
	  
	  
	  
	  
	end
      end

      class 149168 "VecConstraintBlockInfo"
	visibility package stereotype "typedef" base_type class_ref 149040 // ConstraintBlockInfo
	cpp_decl "${comment}typedef helper::vector<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 140848 // <dependency>
	  relation 140848 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 140848 // <dependency>
	    b parent class_ref 149040 // ConstraintBlockInfo
	end
      end

      operation 183088 "getConstraintInfo"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 5
	  param inout name "" type class_ref 149168 // VecConstraintBlockInfo
	  param inout name "" type class_ref 148144 // VecPersistentID
	  param inout name "" type class_ref 148400 // VecConstCoord
	  param inout name "" type class_ref 148656 // VecConstDeriv
	  param inout name "" type class_ref 148912 // VecConstArea
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}, ${t3} & ${p3}${v3}, ${t4} & ${p4}${v4}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ Get information for each constraint: pointer to parent BaseConstraint, unique persistent ID, 3D position"
      end

      operation 183216 "getConstraintResolution"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param inout name "" explicit_type "std::vector<ConstraintResolution*>"
	  param inout name "" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ Add the corresponding ConstraintResolution using the offset parameter"
      end
    end

    class 147888 "BaseConstraintSet"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 141232 // <generalisation>
	relation 141232 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 141232 // <generalisation>
	  b parent class_ref 149424 // typedef7
      end

      classrelation 141360 // <generalisation>
	relation 141360 ---|>
	  a private
	    cpp default "${type}"
	    classrelation_ref 141360 // <generalisation>
	  b parent class_ref 128304 // BaseObject
      end

      operation 185008 "BaseConstraintSet"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} : group(initData(&group, 0, \"group\", \"ID of the group containing this constraint. This ID is used to specify which constraints are solved by which solver, by specifying in each solver which groups of constraints it should handle.\"))
	, m_constraintIndex(initData(&m_constraintIndex, (unsigned int)0, \"constraintIndex\", \"Constraint index (first index in the right hand term resolution vector)\"))
	{
	};
"
	
	
	
	
      end

      operation 185136 "~BaseConstraintSet"
	cpp_virtual cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} { };
"
	
	
	
	
      end

      operation 185264 "resetConstraint"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
      end

      operation 185392 "buildConstraintMatrix"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "cId" type class_ref 129072 // MultiMatrixDerivId
	  param inout name "cIndex" explicit_type "uint"
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Construct the Jacobian Matrix
/
/ \\param cId is the result constraint sparse matrix Id
/ \\param cIndex is the index of the next constraint equation: when building the constraint matrix, you have to use this index, and then update it
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)"
      end

      operation 185520 "getConstraintViolation"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param inout name "v" explicit_type "defaulttype::BaseVector"
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Construct the Constraint violations vector
/
/ \\param v is the result vector that contains the whole constraints violations
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)"
      end

      operation 185648 "useMask"
	const cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {return false;};
"
	
	
	
	
	comment "/ If the constraint is applied only on a subset of particles.
/ That way, we can optimize the time spent traversing the mappings
/ Deactivated by default. The constraints using only a subset of particles should activate the mask,
/ and during buildConstraintMatrix(), insert the indices of the particles modified"
      end

      attribute 140720 "group"
	protected explicit_type " int "
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 140848 "m_constraintIndex"
	protected explicit_type " unsigned int "
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "/ Constraint index (first index in the right hand term resolution vector)"
      end
    end

    class 149296 "BaseConstraintCorrection"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " namespace defaulttype
 namespace sofa
/ @TODO All methods in this class need to be commented
*
 *  \\brief Component computing contact forces within a simulated body using the compliance method."
      classrelation 140976 // <generalisation>
	relation 140976 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 140976 // <generalisation>
	  b parent class_ref 149424 // typedef7
      end

      classrelation 141104 // <generalisation>
	relation 141104 ---|>
	  a private
	    cpp default "${type}"
	    classrelation_ref 141104 // <generalisation>
	  b parent class_ref 128304 // BaseObject
      end

      operation 183344 "~BaseConstraintCorrection"
	cpp_virtual cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {};
"
	
	
	
	
      end

      operation 183472 "getCompliance"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param inout name "W" explicit_type "defaulttype::BaseMatrix"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 183600 "getComplianceMatrix"
	abstract const cpp_virtual public explicit_return_type "void"
	nparams 1
	  param inout name "m" explicit_type "defaulttype::BaseMatrix"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "Fill the matrix m with the full Compliance Matrix"
      end

      operation 183728 "getComplianceWithConstraintMerge"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param inout name "" explicit_type "defaulttype::BaseMatrix"
	  param inout name "" explicit_type "std::vector<int>"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
		sout << \"getComplianceWithConstraintMerge is not implemented yet \" << sendl;
	};
"
	
	
	
	
	comment " for multigrid approach => constraints are merged"
      end

      operation 183856 "CudaGetCompliance"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 1
	  param inout name "W" explicit_type "defaulttype::BaseMatrix"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
		sout << \"warning : CudaGetCompliance(defaulttype::BaseMatrix* W) is not implemented in \" << this->getTypeName() << sendl;
		getCompliance(W); // par defaut si la methode cuda n'est pas implementé on resoud sur CPU
	};
"
	
	
	
	
      end

      operation 183984 "applyContactForce"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "f" explicit_type "defaulttype::BaseVector"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 184112 "applyPredictiveConstraintForce"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "f" explicit_type "defaulttype::BaseVector"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "=> new name: computeAndApplyMotionOfConstraintCorrection ?"
      end

      operation 184240 "resetContactForce"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 184368 "hasConstraintNumber"
	cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 1
	  param in name "" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {return true;};
"
	
	
	
	
	comment " NEW : for non building the constraint system during solving///////////////// "
      end

      operation 184496 "resetForUnbuiltResolution"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param inout name "" explicit_type "double"
	  param inout name "" explicit_type "std::list<int>"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
      end

      operation 184624 "addConstraintDisplacement"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 3
	  param inout name "" explicit_type "double"
	  param in name "" explicit_type "int"
	  param in name "" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
      end

      operation 184752 "setConstraintDForce"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 4
	  param inout name "" explicit_type "double"
	  param in name "" explicit_type "int"
	  param in name "" explicit_type "int"
	  param in name "" explicit_type "bool"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
      end

      operation 184880 "getBlockDiagonalCompliance"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 3
	  param inout name "" explicit_type "defaulttype::BaseMatrix"
	  param in name "" explicit_type "int"
	  param in name "" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
		sout << \"warning : getBlockDiagonalCompliance(defaulttype::BaseMatrix* W) is not implemented in \" << this->getTypeName() << sendl;
	};
"
	
	
	
	
	comment " f += df"
      end
    end

    class 149424 "typedef7"
      visibility package stereotype "typedef" explicit_base_type "virtual"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
    end

    class 149552 "BaseController"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 * @brief BaseController Class.
 * Interface of user interaction on SOFA Components.
 * Empty class to provide an interface for the Factory"
      classrelation 141488 // <generalisation>
	relation 141488 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 141488 // <generalisation>
	  b parent class_ref 149424 // typedef7
      end

      classrelation 141616 // <generalisation>
	relation 141616 ---|>
	  a private
	    cpp default "${type}"
	    classrelation_ref 141616 // <generalisation>
	  b parent class_ref 128304 // BaseObject
      end
    end

    class 149680 "BaseForceField"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component computing forces within simulated bodies.
 *
 *  This class define the abstract API common to all force fields.
 *  A force field computes forces applied to one or more simulated body
 *  given its current position and velocity.
 *
 *  Forces can be internal to a given body (attached to one MechanicalState,
 *  see the ForceField class), or link several bodies together (such as contact
 *  forces, see the InteractionForceField class).
 *
 *  For implicit integration schemes, it must also compute the derivative
 *  ( df, given a displacement dx ).
 *"
      classrelation 141744 // <generalisation>
	relation 141744 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 141744 // <generalisation>
	  b parent class_ref 149424 // typedef7
      end

      classrelation 141872 // <generalisation>
	relation 141872 ---|>
	  a private
	    cpp default "${type}"
	    classrelation_ref 141872 // <generalisation>
	  b parent class_ref 128304 // BaseObject
      end

      operation 185776 "~BaseForceField"
	cpp_virtual cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {};
"
	
	
	
	
      end

      operation 185904 "addForce"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "fId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @name Vector operations
/ @{
/ Given the current position and velocity states, update the current force
/ vector by computing and adding the forces associated with this
/ ForceField.
/
/ If the ForceField can be represented as a matrix, this method computes
/                          $ f += B v + K x $
/ \\param mparams defines the state vectors to use for positions, velocities, forces: mparams->getX(), mparams->getV(), and mparams->getF(), respectively.
/ If mparams->energy() is true, compute and internally store the potential energy, which will be subsequently returned by method getPotentialEnergy()
/ K is the stiffness matrix (associated with forces which derive from a potential),
/ B is the damping matrix (associated with viscous forces),
/ Very often, at least one of these matrices is null.
/ \\param mparams->getX() input vector of position
/ \\param mparams->getV() input vector of velocity
/ \\param fId output vector of forces"
      end

      operation 186032 "addDForce"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "dfId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Compute the force derivative given a small displacement from the
/ position and velocity used in the previous call to addForce().
/
/ The derivative should be directly derived from the computations
/ done by addForce. Any forces neglected in addDForce will be integrated
/ explicitly (i.e. using its value at the beginning of the timestep).
/
/ If the ForceField can be represented as a matrix, this method computes
/                    $ df += kFactor K dx + bFactor B dx $
/ K is the stiffness matrix (associated with forces which derive from a potential),
/ B is the damping matrix (associated with viscous forces)
/ \\param mparams->getDx() input vector
/ \\param dfId output vector
/ \\param mparams->mFactor() coefficient for mass contributions (i.e. second-order derivatives term in the ODE)
/ \\param mparams->kFactor() coefficient for stiffness contributions (i.e. DOFs term in the ODE)"
      end

      operation 186160 "addMBKdx"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "dfId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Accumulate the contribution of M, B, and/or K matrices multiplied
/ by the dx vector with the given coefficients.
/
/ This method computes
/ $ df += mFactor M dx + bFactor B dx + kFactor K dx $
/ In most cases only one of these matrices will be non-null for a given
/ component. For forcefields without mass it simply calls addDForce.
/
/ M is the mass matrix (associated with inertial forces),
/ K is the stiffness matrix (associated with forces which derive from a potential),
/ B is the damping matrix (associated with viscous forces),
/ Very often, at least one of these matrices is null.
/ \\param mparams->getDx() input vector
/ \\param dfId output vector
/ \\param mparams->mFactor() coefficient for mass contributions (i.e. second-order derivatives term in the ODE)
/ \\param mparams->bFactor() coefficient for damping contributions (i.e. first derivatives term in the ODE)
/ \\param mparams->kFactor() coefficient for stiffness contributions (i.e. DOFs term in the ODE)"
      end

      operation 186288 "getPotentialEnergy"
	abstract const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	    defaultvalue "MechanicalParams::defaultInstance() "
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Get the potential energy associated to this ForceField during the last call of addForce( const MechanicalParams* mparams );
/
/ Used to extimate the total energy of the system by some
/ post-stabilization techniques."
      end

      operation 186416 "addKToMatrix"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "matrix" type class_ref 149808 // MultiMatrixAccessor
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @}
/ @name Matrix operations
/ @{
/ Compute the system matrix corresponding to k K
/
/ \\param matrix matrix to add the result to
/ \\param mparams->kFactor() coefficient for stiffness contributions (i.e. DOFs term in the ODE)"
      end

      operation 186544 "addBToMatrix"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "matrix" type class_ref 149808 // MultiMatrixAccessor
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "virtual void addKToMatrix(sofa::defaulttype::BaseMatrix * matrix, double kFact, unsigned int &offset);
/ Compute the system matrix corresponding to b B
/
/ \\param matrix matrix to add the result to
/ \\param mparams->bFactor() coefficient for damping contributions (i.e. first derivatives term in the ODE)"
      end

      operation 186672 "addMBKToMatrix"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "matrix" type class_ref 149808 // MultiMatrixAccessor
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "virtual void addBToMatrix(sofa::defaulttype::BaseMatrix * matrix, double bFact, unsigned int &offset);
/ Compute the system matrix corresponding to m M + b B + k K
/
/ \\param matrix matrix to add the result to
/ \\param mparams->mFactor() coefficient for mass contributions (i.e. second-order derivatives term in the ODE)
/ \\param mparams->bFactor() coefficient for damping contributions (i.e. first derivatives term in the ODE)
/ \\param mparams->kFactor() coefficient for stiffness contributions (i.e. DOFs term in the ODE)"
      end

      operation 186800 "useMask"
	const cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return false; };
"
	
	
	
	
	comment "//virtual void addMBKToMatrix(sofa::defaulttype::BaseMatrix * matrix, double mFact, double bFact, double kFact, unsigned int &offset);
/ @}
/ If the forcefield is applied only on a subset of particles. 
/ That way, we can optimize the time spent to transfer forces through the mechanical mappings
/ Deactivated by default. The forcefields using only a subset of particles should activate the mask,
/ and during addForce(), insert the indices of the particles modified"
      end
    end

    class 149808 "MultiMatrixAccessor"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "/ Abstract class allowing to find the part of the mechanical matrix
/ associated with a given MechanicalState or pair of MechanicalState
/ (for interaction forces and mappings).
/"
      operation 228272 "~MultiMatrixAccessor"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      class 166064 "MatrixRef"
	visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	attribute 144944 "matrix"
	  public explicit_type "defaulttype::BaseMatrix"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	attribute 145072 "offset"
	  public explicit_type "uint"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	operation 228400 "MatrixRef"
	  cpp_inline public explicit_return_type ""
	  nparams 0
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} : matrix(NULL), offset(0) {};
"
	  
	  
	  
	  
	end

	operation 228528 "operator ->"
	  const cpp_inline public explicit_return_type "defaulttype::BaseMatrix"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return matrix; };
"
	  
	  
	  
	  
	end

	operation 228656 "operator !"
	  const cpp_inline public explicit_return_type "bool"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return matrix == NULL; };
"
	  
	  
	  
	  
	end

	operation 228784 "operator bool"
	  const cpp_inline public explicit_return_type ""
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${name}${(}${)}${const}${volatile}${throw}${abstract} { return matrix != NULL; };
"
	  
	  
	  
	  
	end
      end

      class 166192 "InteractionMatrixRef"
	visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	attribute 145200 "matrix"
	  public explicit_type "defaulttype::BaseMatrix"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	operation 228912 "InteractionMatrixRef"
	  cpp_inline public explicit_return_type ""
	  nparams 0
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} : matrix(NULL), offRow(0), offCol(0) {};
"
	  
	  
	  
	  
	end

	operation 229040 "operator ->"
	  const cpp_inline public explicit_return_type "defaulttype::BaseMatrix"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return matrix; };
"
	  
	  
	  
	  
	end

	operation 229168 "operator !"
	  const cpp_inline public explicit_return_type "bool"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return matrix == NULL; };
"
	  
	  
	  
	  
	end

	operation 229296 "operator bool"
	  const cpp_inline public explicit_return_type ""
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${name}${(}${)}${const}${volatile}${throw}${abstract} { return matrix != NULL; };
"
	  
	  
	  
	  
	end
      end

      operation 229424 "addMechanicalState"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "mstate" type class_ref 150064 // BaseMechanicalState
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 229552 "addMechanicalMapping"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "mapping" type class_ref 128048 // BaseMapping
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 229680 "addMappedMechanicalState"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "mstate" type class_ref 150064 // BaseMechanicalState
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 229808 "getGlobalDimension"
	abstract const cpp_virtual public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 229936 "getGlobalOffset"
	abstract const cpp_virtual public explicit_return_type "int"
	nparams 1
	  param in name "mstate" type class_ref 150064 // BaseMechanicalState
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 230064 "getMatrix"
	abstract const cpp_virtual public return_type class_ref 166064 // MatrixRef
	nparams 1
	  param in name "mstate" type class_ref 150064 // BaseMechanicalState
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 230192 "getMatrix"
	abstract const cpp_virtual public return_type class_ref 166192 // InteractionMatrixRef
	nparams 2
	  param in name "mstate1" type class_ref 150064 // BaseMechanicalState
	  param in name "mstate2" type class_ref 150064 // BaseMechanicalState
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end
    end

    class 149936 "BaseInteractionConstraint"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief BaseInteractionConstraint is a constraint linking several bodies (MechanicalState) together.
 *
 *  A BaseInteractionConstraint computes constraints applied to several simulated
 *  bodies given their current positions and velocities.
 *"
      classrelation 142000 // <generalisation>
	relation 142000 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 142000 // <generalisation>
	  b parent class_ref 147760 // BaseConstraint
      end

      operation 186928 "getMechModel1"
	abstract cpp_virtual public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Get the first MechanicalState
/ \\todo Rename to getMechState1()
/ \\todo Replace with an accessor to a list of states, as an InteractionConstraint can be applied to more than two."
      end

      operation 187056 "getMechModel2"
	abstract cpp_virtual public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Get the first MechanicalState
/ \\todo Rename to getMechState2()
/ \\todo Replace with an accessor to a list of states, as an InteractionConstraint can be applied to more than two."
      end
    end

    class 150064 "BaseMechanicalState"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component storing all state vectors of a simulated body (position, velocity, etc).
 *
 *  This class only contains the data of the body and not any of its
 *  <i>active</i> computations, which are handled by the Mass, ForceField, and
 *  Constraint components.
 *
 *  Two types of vectors are used :
 *  \\li \\code VecCoord \\endcode : containing positions.
 *  \\li \\code VecDeriv \\endcode : derivative values, i.e. velocity, forces, displacements.
 *  In most cases they are the same (i.e. 3D/2D point particles), but they can
 *  be different (rigid frames for instance).
 *
 *  Several pre-defined vectors are stored :
 *  \\li \\code position \\endcode
 *  \\li \\code velocity \\endcode
 *  \\li \\code force \\endcode
 *  \\li \\code dx \\endcode (displacement)
 *
 *  Other vectors can be allocated to store other temporary values.
 *  Vectors can be assigned efficiently by just swapping pointers.
 *
 *  In addition to state vectors, the current constraint system matrix is also
 *  stored, containing the coefficient of each constraint defined over the DOFs
 *  in this body.
 *"
      classrelation 143408 // <generalisation>
	relation 143408 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 143408 // <generalisation>
	  b parent class_ref 149424 // typedef7
      end

      classrelation 143536 // <generalisation>
	relation 143536 ---|>
	  a private
	    cpp default "${type}"
	    classrelation_ref 143536 // <generalisation>
	  b parent class_ref 129456 // BaseState
      end

      operation 193328 "BaseMechanicalState"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}
: useMask(initData(&useMask, true, \"useMask\", \"Usage of a mask to optimize the computation of the system, highly reducing the passage through the mappings\"))
, forceMask(&useMask)
${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 193456 "~BaseMechanicalState"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 193584 "getPX"
	const cpp_virtual cpp_inline public explicit_return_type "double"
	nparams 1
	  param in name "" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return 0.0; };
"
	
	
	
	
	comment "/ @name Methods allowing to have access to the geometry without a template class (generic but not efficient)
/ @{"
      end

      operation 193712 "getPY"
	const cpp_virtual cpp_inline public explicit_return_type "double"
	nparams 1
	  param in name "" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return 0.0; };
"
	
	
	
	
      end

      operation 193840 "getPZ"
	const cpp_virtual cpp_inline public explicit_return_type "double"
	nparams 1
	  param in name "" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return 0.0; };
"
	
	
	
	
      end

      operation 193968 "vAvail"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param inout name "v" type class_ref 143920 // VecCoordId
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @}
/ @name Vectors allocation and generic operations (based on VecId)
/ @{
/ Increment the index of the given VecCoordId, so that all 'allocated' vectors in this state have a lower index"
      end

      operation 194096 "vAvail"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param inout name "v" type class_ref 144048 // VecDerivId
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Increment the index of the given VecDerivId, so that all 'allocated' vectors in this state have a lower index"
      end

      operation 194224 "vAlloc"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "v" type class_ref 143920 // VecCoordId
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Increment the index of the given MatrixDerivId, so that all 'allocated' vectors in this state have a lower index
virtual void vAvail(MatrixDerivId& v) = 0;
/ Allocate a new temporary vector"
      end

      operation 194352 "vAlloc"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "v" type class_ref 144048 // VecDerivId
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Allocate a new temporary vector"
      end

      operation 194480 "vFree"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "v" type class_ref 143920 // VecCoordId
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Allocate a new temporary vector
virtual void vAlloc(MatrixDerivId v) = 0;
/ Free a temporary vector"
      end

      operation 194608 "vFree"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "v" type class_ref 144048 // VecDerivId
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Free a temporary vector"
      end

      operation 194736 "vInit"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "v" type class_ref 143920 // VecCoordId
	  param in name "vSrc" type class_ref 133168 // ConstVecCoordId
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Free a temporary vector
virtual void vFree(MatrixDerivId v) = 0;
/ Initialize an unset vector"
      end

      operation 194864 "vInit"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "v" type class_ref 144048 // VecDerivId
	  param in name "vSrc" type class_ref 133296 // ConstVecDerivId
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Initialize an unset vector"
      end

      operation 194992 "vOp"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 5
	  param in name "v" type class_ref 147120 // VecId
	  param in name "a" type class_ref 146992 // ConstVecId
	    defaultvalue "ConstVecId::null()"
	  param in name "b" type class_ref 146992 // ConstVecId
	    defaultvalue "ConstVecId::null()"
	  param in name "f" explicit_type "double"
	    defaultvalue "1.0"
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance() "
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, const ${t4} * ${p4}${v4}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Initialize an unset vector
virtual void vInit(MatrixDerivId v, ConstMatrixDerivId vSrc, const ExecParams* params = ExecParams::defaultInstance()) = 0;
/ Compute a linear operation on vectors : v = a + b * f.
/
/ This generic operation can be used for many simpler cases :
/ \\li v = 0
/ \\li v = a
/ \\li v = a + b
/ \\li v = b * f"
      end

      operation 195120 "vOp"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 6
	  param in name "v" type class_ref 147120 // VecId
	  param in name "a" type class_ref 146992 // ConstVecId
	  param in name "b" type class_ref 146992 // ConstVecId
	  param in name "f" explicit_type "double"
	  param inout name "fSh" explicit_type "a1::Shared<double>"
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance() "
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} * ${p4}${v4}, const ${t5} * ${p5}${v5}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 195248 "vOpMEq"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 4
	  param in name "v" type class_ref 147120 // VecId
	  param in name "a" type class_ref 146992 // ConstVecId
	    defaultvalue "ConstVecId::null()"
	  param inout name "fSh" explicit_type "a1::Shared<double>"
	    defaultvalue "NULL"
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance() "
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} * ${p2}${v2}, const ${t3} * ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 195376 "vDot"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 4
	  param inout name "result" explicit_type "a1::Shared<double>"
	  param in name "a" type class_ref 146992 // ConstVecId
	  param in name "b" type class_ref 146992 // ConstVecId
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance() "
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, const ${t3} * ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      class 151600 "VMultiOpEntry"
	visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 143664 // <generalisation>
	  relation 143664 ---|>
	    a public
	      cpp default "${type}"
	      classrelation_ref 143664 // <generalisation>
	    b parent class_ref 151728 // typedef8
	end

	class 151856 "Fact"
	  visibility package stereotype "typedef" base_type class_ref 140336 // ConstMultiVecId
	  cpp_decl "${comment}typedef std::pair<${type},double> ${name};
"
	  java_decl ""
	  php_decl ""
	  python_2_2 python_decl ""
	  idl_decl ""
	  explicit_switch_type ""
	  
	  classrelation 143792 // <dependency>
	    relation 143792 -_->
	      a default
		cpp default "#include in source"
		classrelation_ref 143792 // <dependency>
	      b parent class_ref 140336 // ConstMultiVecId
	  end
	end

	class 151984 "VecFact"
	  visibility package stereotype "typedef" base_type class_ref 151856 // Fact
	  cpp_decl "${comment}typedef helper::vector<${type}> ${name};
"
	  java_decl ""
	  php_decl ""
	  python_2_2 python_decl ""
	  idl_decl ""
	  explicit_switch_type ""
	  
	  classrelation 143920 // <dependency>
	    relation 143920 -_->
	      a default
		cpp default "#include in source"
		classrelation_ref 143920 // <dependency>
	      b parent class_ref 151856 // Fact
	  end
	end

	class 152112 "Inherit"
	  visibility package stereotype "typedef" base_type class_ref 140464 // MultiVecId
	  cpp_decl "${comment}typedef std::pair<${type},VecFact> ${name};
"
	  java_decl ""
	  php_decl ""
	  python_2_2 python_decl ""
	  idl_decl ""
	  explicit_switch_type ""
	  
	  classrelation 144048 // <dependency>
	    relation 144048 -_->
	      a default
		cpp default "#include in source"
		classrelation_ref 144048 // <dependency>
	      b parent class_ref 140464 // MultiVecId
	  end
	end

	operation 195504 "VMultiOpEntry"
	  cpp_inline public explicit_return_type ""
	  nparams 0
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} : Inherit(MultiVecId::null(), VecFact()) {};
"
	  
	  
	  
	  
	end

	operation 195632 "VMultiOpEntry"
	  cpp_inline public explicit_return_type ""
	  nparams 1
	    param in name "v" type class_ref 140464 // MultiVecId
	  cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw} : Inherit(v, VecFact()) {};
"
	  
	  
	  
	  
	end

	operation 195760 "VMultiOpEntry"
	  cpp_inline public explicit_return_type ""
	  nparams 3
	    param in name "v" type class_ref 140464 // MultiVecId
	    param in name "a" type class_ref 140336 // ConstMultiVecId
	    param in name "af" explicit_type "double"
	      defaultvalue "1.0"
	  cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw} : Inherit(v, VecFact())
        { this->second.push_back(Fact(a, af)); };
"
	  
	  
	  
	  
	end

	operation 195888 "VMultiOpEntry"
	  cpp_inline public explicit_return_type ""
	  nparams 4
	    param in name "v" type class_ref 140464 // MultiVecId
	    param in name "a" type class_ref 140336 // ConstMultiVecId
	    param in name "b" type class_ref 140336 // ConstMultiVecId
	    param in name "bf" explicit_type "double"
	      defaultvalue "1.0"
	  cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}${)}${volatile}${throw} : Inherit(v, VecFact())
        { this->second.push_back(Fact(a,1.0));  this->second.push_back(Fact(b, bf)); };
"
	  
	  
	  
	  
	end

	operation 196016 "VMultiOpEntry"
	  cpp_inline public explicit_return_type ""
	  nparams 5
	    param in name "v" type class_ref 140464 // MultiVecId
	    param in name "a" type class_ref 140336 // ConstMultiVecId
	    param in name "af" explicit_type "double"
	    param in name "b" type class_ref 140336 // ConstMultiVecId
	    param in name "bf" explicit_type "double"
	      defaultvalue "1.0"
	  cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}${)}${volatile}${throw} : Inherit(v, VecFact())
        { this->second.push_back(Fact(a, af));  this->second.push_back(Fact(b, bf)); };
"
	  
	  
	  
	  
	end
      end

      class 151728 "typedef8"
	visibility package stereotype "typedef" explicit_base_type "std::pair< MultiVecId, helper::vector< std::pair< ConstMultiVecId, double > > >"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 152240 "VMultiOp"
	visibility package stereotype "typedef" base_type class_ref 151600 // VMultiOpEntry
	cpp_decl "${comment}typedef helper::vector<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 144176 // <dependency>
	  relation 144176 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 144176 // <dependency>
	    b parent class_ref 151600 // VMultiOpEntry
	end
      end

      operation 196144 "vMultiOp"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "ops" type class_ref 152240 // VMultiOp
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Perform a sequence of linear vector accumulation operation $r_i = sum_j (v_j*f_{ij})$
/
/ This is used to compute in on steps operations such as $v = v + a*dt, x = x + v*dt$.
/ Note that if the result vector appears inside the expression, it must be the first operand.
/ By default this method decompose the computation into multiple vOp calls."
      end

      operation 196272 "vDot"
	abstract cpp_virtual public explicit_return_type "double"
	nparams 3
	  param in name "a" type class_ref 146992 // ConstVecId
	  param in name "b" type class_ref 146992 // ConstVecId
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Compute the scalar products between two vectors."
      end

      operation 196400 "vThreshold"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "a" type class_ref 147120 // VecId
	  param in name "threshold" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "{ return 0; }
/ Apply a threshold to all entries"
      end

      operation 196528 "beginIntegration"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        // it is no longer necessary to switch forceId to internalForce here...
    };
"
	
	
	
	
	comment "/ @}
/ @name Mechanical integration related methods
/ Note: all these methods can now be implemented generically using VecId-based operations
/ @{
/ Called at the beginning of each integration step."
      end

      operation 196656 "endIntegration"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "" explicit_type "double"
	  param in name "params" type class_ref 132912 // ExecParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
        vOp(VecId::externalForce(), ConstVecId::null(), ConstVecId::null(), 1.0, params); // externalForce = 0
    };
"
	
	
	
	
	comment "/ Called at the end of each integration step."
      end

      operation 196784 "resetForce"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "f" type class_ref 147120 // VecId
	    defaultvalue "VecId::force()"
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} { vOp( f, ConstVecId::null(), ConstVecId::null(), 1.0, params ); };
"
	
	
	
	
	comment "/ Set F = 0"
      end

      operation 196912 "resetAcc"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "a" type class_ref 147120 // VecId
	    defaultvalue "VecId::dx() /* VecId::accFromFrame() */"
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance() "
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} { vOp( a, ConstVecId::null(), ConstVecId::null(), 1.0, params ); };
"
	
	
	
	
	comment "/ Set Acc =0"
      end

      operation 197040 "accumulateForce"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "f" type class_ref 147120 // VecId
	    defaultvalue "VecId::force()"
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance() "
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
        vOp( f, f, ConstVecId::externalForce(), 1.0, params ); // f += externalForce
    };
"
	
	
	
	
	comment "/ Add stored external forces to F"
      end

      operation 197168 "resetConstraint"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @}
/ @name Constraints related methods
/ @{
/ Reset the constraint matrix"
      end

      operation 197296 "renumberConstraintId"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "renumbering" explicit_type "sofa::helper::vector<unsigned>"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Renumber the constraint ids with the given permutation vector"
      end

      class 152368 "ConstraintBlock"
	visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	operation 197424 "ConstraintBlock"
	  cpp_inline public explicit_return_type ""
	  nparams 2
	    param in name "c" explicit_type "uint"
	    param inout name "m" explicit_type "defaulttype::BaseMatrix"
	  cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} * ${p1}${v1}${)}${volatile}${throw} :column(c),matrix(m){};
"
	  
	  
	  
	  
	end

	operation 197552 "getColumn"
	  const cpp_inline public explicit_return_type "uint"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {return column;};
"
	  
	  
	  
	  
	end

	operation 197680 "getMatrix"
	  const cpp_inline public explicit_return_type "defaulttype::BaseMatrix"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} & ${name}${(}${)}${const}${volatile}${throw}${abstract} {return *matrix;};
"
	  
	  
	  
	  
	end

	operation 197808 "getMatrix"
	  cpp_inline public explicit_return_type "defaulttype::BaseMatrix"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {return matrix;};
"
	  
	  
	  
	  
	end

	attribute 141872 "column"
	  protected explicit_type "uint"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	attribute 142000 "matrix"
	  protected explicit_type "defaulttype::BaseMatrix"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end
      end

      operation 197936 "constraintBlocks"
	const cpp_virtual cpp_inline public explicit_return_type "std::list<ConstraintBlock>"
	nparams 1
	  param in name "" explicit_type "std::list<unsigned int>"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {  return std::list<ConstraintBlock>();  };
"
	
	
	
	
	comment "/ Express the matrix L in term of block of matrices, using the indices of the lines in the MatrixDeriv container"
      end

      operation 198064 "getConstraintJacobianTimesVecDeriv"
	cpp_virtual cpp_inline public explicit_return_type "SReal"
	nparams 2
	  param in name "" explicit_type "uint"
	  param in name "" type class_ref 146992 // ConstVecId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {  this->serr << \"NOT IMPLEMENTED YET\" << this->sendl; return (SReal)0;  };
"
	
	
	
	
	comment "/ Compute the error given a state vector and a line of the Jacobian (line in vector C)"
      end

      operation 198192 "getCompliance"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 1
	  param inout name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { };
"
	
	
	
	
	comment "/ new : get compliance on the constraints"
      end

      operation 198320 "applyContactForce"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 1
	  param inout name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { };
"
	
	
	
	
	comment "/ apply contact force AND compute the subsequent dX"
      end

      operation 198448 "resetContactForce"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "" explicit_type "void"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
      end

      operation 198576 "addDxToCollisionModel"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "dx" type class_ref 146992 // ConstVecId
	    defaultvalue "ConstVecId::dx() "
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { vOp( VecId::position(), ConstVecId::freePosition(), dx ); };
"
	
	
	
	
      end

      operation 198704 "handleStateChange"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ @}
/ @name events
/   Methods related to Event processing
/ @{
/ Handle state Changes
/ @deprecated topological changes now rely on TopologyEngine"
      end

      operation 198832 "handleStateChange"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 1
	  param inout name "t" type class_ref 152496 // Topology
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "/// Handle state Changes from a given Topology

${inline}${type} ${class}::${name}${(}${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Handle state Changes from a given Topology
/ @deprecated topological changes now rely on TopologyEngine"
      end

      operation 198960 "writeState"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 1
	  param inout name "out" explicit_type "std::ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/@}
/ @name Misc properties and actions
/ @{
/ Write current state to the given output stream"
      end

      operation 199088 "getCoordDimension"
	const cpp_virtual cpp_inline public explicit_return_type "uint"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return 0; };
"
	
	
	
	
      end

      operation 199216 "getDerivDimension"
	const cpp_virtual cpp_inline public explicit_return_type "uint"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return 0; };
"
	
	
	
	
      end

      operation 199344 "applyTranslation"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "dx" explicit_type "double"
	  param in name "dy" explicit_type "double"
	  param in name "dz" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} ${p0}${v0}, const ${t1} ${p1}${v1}, const ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Translate the current state"
      end

      operation 199472 "applyRotation"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 3
	  param in name "" explicit_type "double"
	  param in name "" explicit_type "double"
	  param in name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} ${p0}${v0}, const ${t1} ${p1}${v1}, const ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ Rotate the current state
/ This method is optional, it is used when the user want to interactively change the position of an object using Euler angles"
      end

      operation 199600 "applyRotation"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "q" explicit_type "defaulttype::Quat"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Rotate the current state"
      end

      operation 199728 "applyScale"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "" explicit_type "double"
	  param in name "" explicit_type "double"
	  param in name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} ${p0}${v0}, const ${t1} ${p1}${v1}, const ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Scale the current state"
      end

      operation 199856 "getScale"
	const cpp_virtual cpp_inline public explicit_return_type "defaulttype::Vector3"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return defaulttype::Vector3(1.0,1.0,1.0); };
"
	
	
	
	
      end

      operation 199984 "addBBox"
	cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 2
	  param inout name "" explicit_type "double"
	  param inout name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
      return false;
    };
"
	
	
	
	
      end

      operation 200112 "pickParticles"
	cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 10
	  param in name "" explicit_type "double"
	  param in name "" explicit_type "double"
	  param in name "" explicit_type "double"
	  param in name "" explicit_type "double"
	  param in name "" explicit_type "double"
	  param in name "" explicit_type "double"
	  param in name "" explicit_type "double"
	  param in name "" explicit_type "double"
	  param inout name "" explicit_type "std::multimap< double, std::pair<sofa::core::behavior::BaseMechanicalState*, int> >"
	  param in name "" type class_ref 132912 // ExecParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}, ${t7} ${p7}${v7}, ${t8} & ${p8}${v8}, const ${t9} * ${p9}${v9}${)}${const}${volatile}${throw}${abstract} {
        return false;
    };
"
	
	
	
	
	comment "/ Find mechanical particles hit by the given ray.
/ A mechanical particle is defined as a 2D or 3D, position or rigid DOF
/ Returns false if this object does not support picking"
      end

      attribute 142128 "useMask"
	public explicit_type "bool"
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 142256 "forceMask"
	public explicit_type "helper::ParticleMask"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      operation 200240 "getMatrixBlockSize"
	const cpp_virtual cpp_inline public explicit_return_type "uint"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return getDerivDimension(); };
"
	
	
	
	
	comment "/ @}
/ @name Interface with BaseMatrix / BaseVector
/ @{
/ Get the number of scalars per Deriv value, as necessary to build mechanical matrices and vectors.
/ If not all Derivs have the same number of scalars, then return 1 here and overload the getMatrixSize() method."
      end

      operation 200368 "getMatrixSize"
	const cpp_virtual cpp_inline public explicit_return_type "uint"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return getSize() * getMatrixBlockSize(); };
"
	
	
	
	
	comment "/ Get the number of rows necessary to build mechanical matrices and vectors.
/ In most cases this is equivalent to getSize() * getMatrixBlockSize()."
      end

      operation 200496 "copyToBaseVector"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "dest" explicit_type "defaulttype::BaseVector"
	  param in name "src" type class_ref 146992 // ConstVecId
	  param inout name "offset" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Copy data to a global BaseVector from the state stored in a local vector
/ @param offset the offset in the BaseVector where the scalar values will be used. It will be updated to the first scalar value after the ones used by this operation when this method returns"
      end

      operation 200624 "copyFromBaseVector"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "dest" type class_ref 147120 // VecId
	  param in name "src" explicit_type "defaulttype::BaseVector"
	  param inout name "offset" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Copy data to a local vector from the state stored in a global BaseVector
/ @param offset the offset in the BaseVector where the scalar values will be used. It will be updated to the first scalar value after the ones used by this operation when this method returns"
      end

      operation 200752 "addToBaseVector"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "dest" explicit_type "defaulttype::BaseVector"
	  param in name "src" type class_ref 146992 // ConstVecId
	  param inout name "offset" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Add data to a global BaseVector from the state stored in a local vector
/ @param offset the offset in the BaseVector where the scalar values will be used. It will be updated to the first scalar value after the ones used by this operation when this method returns"
      end

      operation 200880 "addFromBaseVectorSameSize"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "dest" type class_ref 147120 // VecId
	  param in name "src" explicit_type "defaulttype::BaseVector"
	  param inout name "offset" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Performs dest[i][j] += src[offset + i][j] 0<= i < src_entries 0<= j < 3 (for 3D objects) 0 <= j < 2 (for 2D objects)
/ @param offset the offset in the BaseVector where the scalar values will be used. It will be updated to the first scalar value after the ones used by this operation when this method returns"
      end

      operation 201008 "addFromBaseVectorDifferentSize"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "dest" type class_ref 147120 // VecId
	  param in name "src" explicit_type "defaulttype::BaseVector"
	  param inout name "offset" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Performs dest[ offset + i ][j] += src[i][j]  0<= i < src_entries  0<= j < 3 (for 3D objects) 0 <= j < 2 (for 2D objects)  
/ @param offset the offset in the MechanicalObject local vector specified by VecId dest. It will be updated to the first scalar value after the ones used by this operation when this method returns. "
      end

      operation 201136 "printDOF"
	abstract const cpp_virtual public explicit_return_type "void"
	nparams 4
	  param in name "v" type class_ref 146992 // ConstVecId
	  param inout name "out" explicit_type "std::ostream"
	    defaultvalue "std::cerr"
	  param in name "firstIndex" explicit_type "int"
	    defaultvalue "0"
	  param in name "range" explicit_type "int"
	    defaultvalue "-1 "
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @}
/ @name Data output
/ @{"
      end

      operation 201264 "printDOFWithElapsedTime"
	cpp_virtual cpp_inline public explicit_return_type "uint"
	nparams 4
	  param in name "" type class_ref 146992 // ConstVecId
	  param in name "" explicit_type "uint"
	    defaultvalue "0"
	  param in name "" explicit_type "uint"
	    defaultvalue "0"
	  param inout name "" explicit_type "std::ostream"
	    defaultvalue "std::cerr "
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} & ${p3}${v3}${)}${const}${volatile}${throw}${abstract} { return 0; };
"
	
	
	
	
      end

      operation 201392 "initGnuplot"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "" explicit_type "std::string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
      end

      operation 201520 "exportGnuplot"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
      end

      operation 201648 "writeVec"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "v" type class_ref 146992 // ConstVecId
	  param inout name "out" explicit_type "std::ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 201776 "readVec"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "v" type class_ref 147120 // VecId
	  param inout name "in" explicit_type "std::istream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 201904 "compareVec"
	abstract cpp_virtual public explicit_return_type "double"
	nparams 2
	  param in name "v" type class_ref 146992 // ConstVecId
	  param inout name "in" explicit_type "std::istream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end
    end

    class 150192 "BaseInteractionForceField"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief BaseInteractionForceField is a force field linking several bodies (MechanicalState) together.
 *
 *  An interaction force field computes forces applied to several simulated
 *  bodies given their current positions and velocities.
 *
 *  For implicit integration schemes, it must also compute the derivative
 *  ( df, given a displacement dx )."
      classrelation 142128 // <generalisation>
	relation 142128 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 142128 // <generalisation>
	  b parent class_ref 149680 // BaseForceField
      end

      operation 187184 "getMechModel1"
	abstract cpp_virtual public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Get the first MechanicalState
/ \\todo Rename to getMechState1()
/ \\todo Replace with an accessor to a list of states, as an InteractionForceField can be applied to more than two."
      end

      operation 187312 "getMechModel2"
	abstract cpp_virtual public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Get the first MechanicalState
/ \\todo Rename to getMechState2()
/ \\todo Replace with an accessor to a list of states, as an InteractionForceField can be applied to more than two."
      end

      operation 187440 "addKToMatrix"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "matrix" type class_ref 149808 // MultiMatrixAccessor
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
    	sofa::core::behavior::MultiMatrixAccessor::MatrixRef r1 = matrix->getMatrix(getMechModel1());
    	sofa::core::behavior::MultiMatrixAccessor::MatrixRef r2 = matrix->getMatrix(getMechModel2());
		if (r1) addKToMatrix(r1.matrix, mparams->kFactor(), r1.offset);
		if (r2) addKToMatrix(r2.matrix,  mparams->kFactor(), r2.offset);
    };
"
	
	
	
	
      end

      operation 187568 "addKToMatrix"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 3
	  param inout name "" explicit_type "sofa::defaulttype::BaseMatrix"
	  param in name "" explicit_type "double"
	  param inout name "" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        serr << \"ERROR(\"<<getClassName()<<\"): addKToMatrix not implemented.\" << sendl;
    };
"
	
	
	
	
	comment "/ @deprecated"
      end
    end

    class 150320 "BaseInteractionProjectiveConstraintSet"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief BaseInteractionProjectiveConstraintSet is a constraint linking several bodies (MechanicalState) together.
 *
 *  A BaseInteractionProjectiveConstraintSet computes constraints applied to several simulated
 *  bodies given their current positions and velocities.
 *"
      classrelation 142256 // <generalisation>
	relation 142256 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 142256 // <generalisation>
	  b parent class_ref 150448 // BaseProjectiveConstraintSet
      end

      operation 187696 "getMechModel1"
	abstract cpp_virtual public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Get the first MechanicalState
/ \\todo Rename to getMechState1()
/ \\todo Replace with an accessor to a list of states, as an InteractionConstraint can be applied to more than two."
      end

      operation 187824 "getMechModel2"
	abstract cpp_virtual public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Get the first MechanicalState
/ \\todo Rename to getMechState2()
/ \\todo Replace with an accessor to a list of states, as an InteractionConstraint can be applied to more than two."
      end
    end

    class 150448 "BaseProjectiveConstraintSet"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
*  \\brief Component computing projective constraints within a simulated body.
*
*  This class define the abstract API common to all projective constraints.
*  A BaseConstraint computes constraints applied to one or more simulated body
*  given its current position and velocity.
*
*  Constraints can be internal to a given body (attached to one MechanicalState,
*  see the Constraint class), or link several bodies together (such as contacts,
*  see the InteractionConstraint class).
*"
      classrelation 144304 // <generalisation>
	relation 144304 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 144304 // <generalisation>
	  b parent class_ref 149424 // typedef7
      end

      classrelation 144432 // <generalisation>
	relation 144432 ---|>
	  a private
	    cpp default "${type}"
	    classrelation_ref 144432 // <generalisation>
	  b parent class_ref 128304 // BaseObject
      end

      operation 202032 "BaseProjectiveConstraintSet"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} : group(initData(&group, 0, \"group\", \"ID of the group containing this constraint. This ID is used to specify which constraints are solved by which solver, by specifying in each solver which groups of constraints it should handle.\"))
	{
	};
"
	
	
	
	
      end

      operation 202160 "~BaseProjectiveConstraintSet"
	cpp_virtual cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {};
"
	
	
	
	
      end

      operation 202288 "getGroup"
	const cpp_inline public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return group.getValue(); };
"
	
	
	
	
	comment "/ Get the ID of the group containing this constraint.
/ This ID is used to specify which constraints are solved by which solver, by specifying in each solver which groups of constraints it should handle."
      end

      operation 202416 "setGroup"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "g" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { group.setValue(g); };
"
	
	
	
	
	comment "/ Set the ID of the group containing this constraint.
/ This ID is used to specify which constraints are solved by which solver, by specifying in each solver which groups of constraints it should handle."
      end

      operation 202544 "projectResponse"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "dxId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @name Vector operations
/ @{
/ Project dx to constrained space (dx models an acceleration).
/ \\param dxId output vector"
      end

      operation 202672 "projectJacobianMatrix"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "cId" type class_ref 129072 // MultiMatrixDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Project the L matrix of the Lagrange Multiplier equation system.
/ \\param cId output vector"
      end

      operation 202800 "projectVelocity"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "vId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Project v to constrained space (v models a velocity).
/ \\param vId output vector"
      end

      operation 202928 "projectPosition"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "xId" type class_ref 128432 // MultiVecCoordId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Project x to constrained space (x models a position).
/ \\param xId output vector"
      end

      operation 203056 "projectResponse"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param inout name "" explicit_type "double"
	  param in name "" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ @}
/ @name Matrix operations
/ @{
/ Project the compliance Matrix to constrained space."
      end

      operation 203184 "applyConstraint"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "" type class_ref 149808 // MultiMatrixAccessor
	  param in name "" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ Project the global Mechanical Matrix to constrained space using offset parameter"
      end

      operation 203312 "applyConstraint"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 3
	  param inout name "" explicit_type "defaulttype::BaseVector"
	  param in name "" type class_ref 149808 // MultiMatrixAccessor
	  param in name "" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ Project the global Mechanical Vector to constrained space using offset parameter"
      end

      operation 203440 "useMask"
	const cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {return false;};
"
	
	
	
	
	comment "/ @}
/ If the constraint is applied only on a subset of particles.
/ That way, we can optimize the time spent traversing the mappings
/ Deactivated by default. The constraints using only a subset of particles should activate the mask,
/ and during projectResponse(), insert the indices of the particles modified"
      end

      attribute 142384 "group"
	protected explicit_type "int"
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 150576 "ConstraintEquation"
      visibility package stereotype "struct"
      cpp_decl "${comment}${template}struct ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
   * \\brief Expression of a line of the system created to solve the constraint
 *
 * @param idx                  index of the equation in the constraint equation system stored within the mechanical states
 * @param correction           right hand term of the equation: corresponds to a correction we have to apply to the system
 * @param constraintId         actual index of the line corresponding to the constraint equation in the whole system: can be different from idx
 *"
      attribute 140976 "idx"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 141104 "correction"
	public explicit_type "SReal"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 141232 "constraintId"
	public explicit_type "uint"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 150704 "ConstraintGroup"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
   * \\brief Intern storage of the constraints.
   *         a ConstraintGroup is a list of equations that will be solved together.
   *  They are defined by a ConstOrder(position, velocity or acceleration)
   * @see ConstraintEquation
   * @see ConstOrder
   *"
      class 150832 "VecEquations"
	visibility package stereotype "typedef" base_type class_ref 150576 // ConstraintEquation
	cpp_decl "${comment}typedef sofa::helper::vector<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 142384 // <dependency>
	  relation 142384 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 142384 // <dependency>
	    b parent class_ref 150576 // ConstraintEquation
	end
      end

      class 150960 "EquationConstIterator"
	visibility package stereotype "typedef" explicit_base_type "VecEquations::const_iterator"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 151088 "EquationIterator"
	visibility package stereotype "typedef" explicit_base_type "VecEquations::iterator"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      operation 187952 "ConstraintGroup"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param in name "idConstraint" type class_ref 133040 // ConstOrder
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "//------------------------------------------------------------------------
//ConstraintGroup

${inline}${class}::${name}${(}${t0} ${p0}${)}
	: Order(idConstraint)
	, active(true)
${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 188080 "addConstraint"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 3
	  param inout name "constraintId" explicit_type "uint"
	  param in name "idx" explicit_type "uint"
	  param in name "c" explicit_type "SReal"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "*
     * Method to add an interaction constraint to the group
     *
   * @param idx index of the equation
     * @param c  correction we need to apply in order to solve the constraint
     *"
      end

      operation 188208 "getConstraint"
	const cpp_inline public return_type class_ref 150576 // ConstraintEquation
	nparams 1
	  param in name "i" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} & ${name}${(}const ${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
      EquationConstIterator it=equations.begin();
      std::advance(it,i);
      return *it;
    };
"
	
	
	
	
	comment "/ Random Access to an equation"
      end

      operation 188336 "getConstraint"
	cpp_inline public return_type class_ref 150576 // ConstraintEquation
	nparams 1
	  param in name "i" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
      EquationIterator it=equations.begin();
      std::advance(it,i);
      return *it;
    };
"
	
	
	
	
      end

      operation 188464 "data"
	const cpp_inline public explicit_return_type "std::pair< EquationConstIterator,EquationConstIterator>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
      return std::make_pair( equations.begin(), equations.end());
    };
"
	
	
	
	
	comment "/ Retrieve all the equations"
      end

      operation 188592 "data"
	cpp_inline public explicit_return_type "std::pair< EquationIterator,EquationIterator >"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
      return std::make_pair( equations.begin(), equations.end());
    };
"
	
	
	
	
      end

      operation 188720 "getNumConstraint"
	const cpp_inline public explicit_return_type "std::size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return equations.size();};
"
	
	
	
	
	comment "/ Return the number of constraint contained in this group"
      end

      operation 188848 "getOrder"
	const cpp_inline public return_type class_ref 133040 // ConstOrder
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return Order;};
"
	
	
	
	
	comment "/ Return the order of the constraint
/ @see ConstOrder"
      end

      operation 188976 "isActive"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {return active;};
"
	
	
	
	
      end

      operation 189104 "setActive"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "b" explicit_type "bool"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {active=b;};
"
	
	
	
	
      end

      classrelation 142512 // Order (<directional composition>)
	relation 142512 *-->
	  a role_name "Order" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 142512 // Order (<directional composition>)
	  b parent class_ref 133040 // ConstOrder
      end

      classrelation 142640 // equations (<directional composition>)
	relation 142640 *-->
	  a role_name "equations" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 142640 // equations (<directional composition>)
	  b parent class_ref 150832 // VecEquations
      end

      attribute 141360 "active"
	protected explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 151216 "BaseLMConstraint"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
	 * \\brief Object storing constraints base on Lagrangrian Multipliers. 
	 * 
	 *        They can be constraint on acceleration, velocity, or position. 
	 *        They can be grouped or individual. The resolution is then done in the OdeSolver.
	 *"
      classrelation 142768 // <generalisation>
	relation 142768 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 142768 // <generalisation>
	  b parent class_ref 147888 // BaseConstraintSet
      end

      operation 189232 "BaseLMConstraint"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "//------------------------------------------------------------------------

${inline}${class}::${name}${(}${)}
: pathObject1( initData(&pathObject1,  \"object1\",\"First Object to constrain\") ),
  pathObject2( initData(&pathObject2,  \"object2\",\"Second Object to constrain\") )
${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 189360 "~BaseLMConstraint"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {};
"
	
	
	
	
      end

      operation 189488 "writeConstraintEquations"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "lineNumber" explicit_type "uint"
	  param in name "id" type class_ref 140464 // MultiVecId
	  param in name "order" type class_ref 133040 // ConstOrder
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Called by MechanicalWriteLMConstaint: The Object will compute the constraints present in the current state, and create the ConstraintGroup related."
      end

      operation 189616 "LagrangeMultiplierEvaluation"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 4
	  param in name "" explicit_type "SReal"
	  param in name "" explicit_type "SReal"
	  param inout name "" explicit_type "SReal"
	  param inout name "" type class_ref 150704 // ConstraintGroup
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}, ${t3} * ${p3}${v3}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ Compute the new Lagrange Multiplier given a block of the compliance matrix W, and the current correction (left hand term) and previous Lagrange Multiplier"
      end

      operation 189744 "getConstraintViolation"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 2
	  param inout name "v" explicit_type "defaulttype::BaseVector"
	  param in name "cparams" type class_ref 129328 // ConstraintParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Get Right Hand Term"
      end

      operation 189872 "getConstraintViolation"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 2
	  param inout name "v" explicit_type "defaulttype::BaseVector"
	  param in name "Order" type class_ref 133040 // ConstOrder
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, const ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment " Override used in LMConstraintSolver::buildSystem method"
      end

      operation 190000 "getConstraints"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 1
	  param inout name "i" explicit_type "std::map< ConstraintParams::ConstOrder, helper::vector< ConstraintGroup* > >"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { i=constraintOrder;};
"
	
	
	
	
	comment "/ Get the internal structure: return all the constraint stored by their nature in a map"
      end

      operation 190128 "getConstraintsOrder"
	const cpp_virtual cpp_inline public explicit_return_type "helper::vector< ConstraintGroup* >"
	nparams 1
	  param in name "Order" type class_ref 133040 // ConstOrder
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} & ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
		  constraintOrder_t::const_iterator c = constraintOrder.find( Order );
		  assert( c != constraintOrder.end());
		  return c->second;
	  };
"
	
	
	
	
	comment "/ Get all the constraints stored of a given nature"
      end

      operation 190256 "getEquationsUsed"
	stereotype "template"
	const cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "group" type class_ref 150704 // ConstraintGroup
	  param inout name "used0" explicit_type "DataStorage"
	cpp_decl "    ${comment}template<typename DataStorage>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
          typedef ConstraintGroup::EquationConstIterator iterator_t;
          std::pair< iterator_t, iterator_t > range=group->data();
          for (iterator_t equation=range.first; equation!=range.second;++equation) used0.push_back(equation->idx);
      };
"
	
	
	
	
	comment "/ Get Left Hand Term for a given constraint group"
      end

      operation 190384 "getEquationsUsed"
	stereotype "template"
	const cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "Order" type class_ref 133040 // ConstOrder
	  param inout name "used0" explicit_type "DataStorage"
	cpp_decl "    ${comment}template<typename DataStorage>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
          constraintOrder_t::const_iterator g = constraintOrder.find(Order);
          if (g == constraintOrder.end()) return;

          const helper::vector< ConstraintGroup* > &constraints = g->second;
          for (unsigned int idxGroupConstraint=0;idxGroupConstraint<constraints.size(); ++idxGroupConstraint)
          {
              ConstraintGroup *group=constraints[idxGroupConstraint];
              getEquationsUsed(group, used0);
          }
      };
"
	
	
	
	
	comment "/ Get Left Hand Term for each ConstraintGroup of a given order"
      end

      operation 190512 "getNumConstraint"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "uint"
	nparams 1
	  param in name "Order" type class_ref 133040 // ConstOrder
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ get the number of expressed constraints of a given order"
      end

      operation 190640 "getConstrainedMechModel1"
	abstract const cpp_virtual public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ get Mechanical State 1 where the constraint will be expressed (can be a Mapped mechanical state)"
      end

      operation 190768 "getConstrainedMechModel2"
	abstract const cpp_virtual public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ get Mechanical State 2 where the constraint will be expressed (can be a Mapped mechanical state)"
      end

      operation 190896 "getSimulatedMechModel1"
	abstract const cpp_virtual public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ get Mechanical State 1 where the constraint will be solved"
      end

      operation 191024 "getSimulatedMechModel2"
	abstract const cpp_virtual public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ get Mechanical State 2 where the constraint will b*e solved"
      end

      operation 191152 "useMask"
	const cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {return false;};
"
	
	
	
	
	comment "/ If the constraint is applied only on a subset of particles. 
/ That way, we can optimize the time spent traversing the mappings
/ Deactivated by default. The constraints using only a subset of particles should activate the mask,
/ and during projectResponse(), insert the indices of the particles modified"
      end

      operation 191280 "isCorrectionComputedWithSimulatedDOF"
	const cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 1
	  param in name "" type class_ref 133040 // ConstOrder
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {return false;};
"
	
	
	
	
	comment "/ Methods to know if we have to propagate the state we want to constrain before computing the correction
/ If the correction is computed with the simulatedDOF, there is no need, and we can reach a good speed-up"
      end

      operation 191408 "resetConstraint"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 191536 "addGroupConstraint"
	preserve_cpp_body_indent cpp_virtual protected return_type class_ref 150704 // ConstraintGroup
	nparams 1
	  param in name "id" type class_ref 133040 // ConstOrder
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} * ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Interface to construct a group of constraint: Giving the order of these constraints, it returns a pointer to the structure
/ @see ConstraintGroup"
      end

      class 151344 "constraintOrder_t"
	visibility package stereotype "typedef" base_type class_ref 133040 // ConstOrder
	cpp_decl "${comment}typedef std::map<${type},helper::vector<ConstraintGroup*> > ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 142896 // <dependency>
	  relation 142896 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 142896 // <dependency>
	    b parent class_ref 133040 // ConstOrder
	end
      end

      classrelation 143024 // constraintOrder (<directional composition>)
	relation 143024 *-->
	  a role_name "constraintOrder" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 143024 // constraintOrder (<directional composition>)
	  b parent class_ref 151344 // constraintOrder_t
      end

      attribute 141488 "pathObject1"
	protected explicit_type "std::string"
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 141616 "pathObject2"
	protected explicit_type "std::string"
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 151472 "BaseMass"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component responsible for mass-related computations (gravity, acceleration).
 *
 *  Mass can be defined either as a scalar, vector, or a full mass-matrix.
 *  It is responsible for converting forces to accelerations (for explicit integrators),
 *  or displacements to forces (for implicit integrators).
 *
 *  It is often also a ForceField, computing gravity-related forces."
      classrelation 143152 // <generalisation>
	relation 143152 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 143152 // <generalisation>
	  b parent class_ref 149424 // typedef7
      end

      classrelation 143280 // <generalisation>
	relation 143280 ---|>
	  a private
	    cpp default "${type}"
	    classrelation_ref 143280 // <generalisation>
	  b parent class_ref 128304 // BaseObject
      end

      operation 191664 "BaseMass"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} : m_separateGravity (initData(&m_separateGravity , false, \"separateGravity\", \"add separately gravity to velocity computation\"))
    {
    };
"
	
	
	
	
      end

      operation 191792 "~BaseMass"
	cpp_virtual cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {
    };
"
	
	
	
	
      end

      operation 191920 "addMDx"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "fid" type class_ref 128816 // MultiVecDerivId
	  param in name "factor" explicit_type "double"
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @name Vector operations
/ @{
/ f += factor M dx"
      end

      operation 192048 "accFromF"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "aid" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ dx = M^-1 f"
      end

      operation 192176 "addGravityToV"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "vid" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Perform  v += dt*g operation. Used if mass wants to added G separately from the other forces to v.
/ \\param mparams->dt() time step of for temporal discretization."
      end

      operation 192304 "getKineticEnergy"
	abstract const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	    defaultvalue "MechanicalParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ vMv/2"
      end

      operation 192432 "getPotentialEnergy"
	abstract const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	    defaultvalue "MechanicalParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Mgx"
      end

      operation 192560 "addMToMatrix"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "matrix" type class_ref 149808 // MultiMatrixAccessor
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @}
/ @name Matrix operations
/ @{
/ Add Mass contribution to global Matrix assembling
/
/ This method must be implemented by the component.
/ \\param matrix matrix to add the result to
/ \\param mparams->mFactor() coefficient for mass contributions (i.e. second-order derivatives term in the ODE)"
      end

      operation 192688 "initGnuplot"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "path" explicit_type "std::string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @}
/ initialization to export kinetic and potential energy to gnuplot files format"
      end

      operation 192816 "exportGnuplot"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "time" explicit_type "double"
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	    defaultvalue "MechanicalParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ export kinetic and potential energy state at \"time\" to a gnuplot file"
      end

      operation 192944 "getElementMass"
	abstract const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "index" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ return the mass relative to the DOF #index"
      end

      operation 193072 "getElementMass"
	abstract const cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "index" explicit_type "uint"
	  param inout name "m" explicit_type "defaulttype::BaseMatrix"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ return the matrix relative to the DOF #index"
      end

      operation 193200 "isDiagonal"
	cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return false; };
"
	
	
	
	
      end

      attribute 141744 "m_separateGravity"
	public explicit_type "bool"
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 152624 "BaseVectorOperations"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 144560 // params (<unidirectional association>)
	relation 144560 --->
	  a role_name "params" const_relation protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 144560 // params (<unidirectional association>)
	  b parent class_ref 132912 // ExecParams
      end

      classrelation 144688 // ctx (<unidirectional association>)
	relation 144688 --->
	  a role_name "ctx" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 144688 // ctx (<unidirectional association>)
	  b parent class_ref 141104 // BaseContext
      end

      attribute 142512 "result"
	protected explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      operation 203568 "BaseVectorOperations"
	cpp_inline public explicit_return_type ""
	nparams 2
	  param in name "params" type class_ref 132912 // ExecParams
	  param inout name "ctx" type class_ref 141104 // BaseContext
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} * ${p0}${v0}, ${t1} * ${p1}${v1}${)}${volatile}${throw} : params(params),ctx(ctx)
    {};
"
	
	
	
	
      end

      operation 203696 "~BaseVectorOperations"
	cpp_virtual cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {};
"
	
	
	
	
      end

      operation 203824 "v_alloc"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param inout name "id" type class_ref 128432 // MultiVecCoordId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Allocate a temporary vector"
      end

      operation 203952 "v_alloc"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param inout name "id" type class_ref 128816 // MultiVecDerivId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 204080 "v_free"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param inout name "id" type class_ref 128432 // MultiVecCoordId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Free a previously allocated temporary vector"
      end

      operation 204208 "v_free"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param inout name "id" type class_ref 128816 // MultiVecDerivId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 204336 "v_clear"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "v" type class_ref 140464 // MultiVecId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 204464 "v_eq"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "v" type class_ref 140464 // MultiVecId
	  param in name "a" type class_ref 140464 // MultiVecId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/< v=0"
      end

      operation 204592 "v_peq"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "v" type class_ref 140464 // MultiVecId
	  param in name "a" type class_ref 140464 // MultiVecId
	  param in name "f" explicit_type "double"
	    defaultvalue "1.0"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/< v=a"
      end

      operation 204720 "v_peq"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 4
	  param in name "v" type class_ref 140464 // MultiVecId
	  param in name "a" type class_ref 140464 // MultiVecId
	  param inout name "fSh" explicit_type "Shared<double>"
	  param in name "f" explicit_type "double"
	    defaultvalue "1.0"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} & ${p2}${v2}, ${t3} ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 204848 "v_meq"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "v" type class_ref 140464 // MultiVecId
	  param in name "a" type class_ref 140464 // MultiVecId
	  param inout name "fSh" explicit_type "Shared<double>"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/< v+=f*a"
      end

      operation 204976 "v_teq"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "v" type class_ref 140464 // MultiVecId
	  param in name "f" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 205104 "v_op"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 4
	  param in name "v" type class_ref 140464 // MultiVecId
	  param in name "a" type class_ref 140336 // ConstMultiVecId
	  param in name "b" type class_ref 140336 // ConstMultiVecId
	  param in name "f" explicit_type "double"
	    defaultvalue "1.0"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/< v*=f"
      end

      operation 205232 "v_op"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 4
	  param in name "v" type class_ref 140464 // MultiVecId
	  param in name "a" type class_ref 140464 // MultiVecId
	  param in name "b" type class_ref 140464 // MultiVecId
	  param inout name "f" explicit_type "Shared<double>"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} & ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 205360 "v_multiop"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "o" type class_ref 152240 // VMultiOp
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 205488 "v_dot"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "a" type class_ref 140336 // ConstMultiVecId
	  param in name "b" type class_ref 140336 // ConstMultiVecId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 205616 "v_dot"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "result" explicit_type "Shared<double>"
	  param in name "a" type class_ref 140464 // MultiVecId
	  param in name "b" type class_ref 140464 // MultiVecId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 205744 "v_threshold"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "a" type class_ref 140464 // MultiVecId
	  param in name "threshold" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 205872 "finish"
	abstract cpp_virtual public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/< nullify the values below the given threshold "
      end

      operation 206000 "print"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "v" type class_ref 140464 // MultiVecId
	  param inout name "out" explicit_type "std::ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end
    end

    class 152752 "Constraint"
      abstract visibility package 
      nformals 1
      formal name "DataTypes" type "class" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component computing constraints within a simulated body.
 *
 *  This class define the abstract API common to constraints using a given type
 *  of DOFs.
 *  A Constraint computes constraints applied to one simulated body given its
 *  current position and velocity.
 *"
      classrelation 144816 // <generalisation>
	relation 144816 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 144816 // <generalisation>
	  b parent class_ref 147760 // BaseConstraint
      end

      class 152880 "Real"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Real"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 153008 "VecCoord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 153136 "VecDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 153264 "Coord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 153392 "Deriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 153520 "MatrixDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::MatrixDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 153648 "DataVecCoord"
	visibility package stereotype "typedef" base_type class_ref 153008 // VecCoord
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 144944 // <dependency>
	  relation 144944 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 144944 // <dependency>
	    b parent class_ref 153008 // VecCoord
	end
      end

      class 153776 "DataVecDeriv"
	visibility package stereotype "typedef" base_type class_ref 153136 // VecDeriv
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 145072 // <dependency>
	  relation 145072 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 145072 // <dependency>
	    b parent class_ref 153136 // VecDeriv
	end
      end

      class 153904 "DataMatrixDeriv"
	visibility package stereotype "typedef" base_type class_ref 153520 // MatrixDeriv
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 145200 // <dependency>
	  relation 145200 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 145200 // <dependency>
	    b parent class_ref 153520 // MatrixDeriv
	end
      end

      operation 206128 "Constraint"
	public explicit_return_type ""
	nparams 1
	  param inout name "mm" explicit_type "MechanicalState<DataTypes>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 206256 "~Constraint"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      classrelation 145328 // endTime (<directional composition>)
	relation 145328 *-->
	  stereotype "Data"
	  a role_name "endTime" public
	    comment "/< Time when the constraint becomes inactive (-1 for infinitely active)"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	    classrelation_ref 145328 // endTime (<directional composition>)
	  b parent class_ref 152880 // Real
      end

      operation 206384 "isActive"
	const cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 206512 "init"
	cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/< if false, the constraint does nothing"
      end

      operation 206640 "getMState"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 206768 "getConstraintViolation"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param inout name "v" explicit_type "defaulttype::BaseVector"
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Construct the Constraint violations vector of each constraint
/
/ \\param v is the result vector that contains the whole constraints violations
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)"
      end

      operation 206896 "getConstraintViolation"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 4
	  param inout name "resV" explicit_type "defaulttype::BaseVector"
	  param in name "x" type class_ref 153648 // DataVecCoord
	  param in name "v" type class_ref 153776 // DataVecDeriv
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}, const ${t3} * ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Construct the Constraint violations vector of each constraint
/
/ \\param resV is the result vector that contains the whole constraints violations
/ \\param x is the position vector used to compute contraint position violation
/ \\param v is the velocity vector used to compute contraint velocity violation
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)
/
/ This is the method that should be implemented by the component"
      end

      operation 207024 "getConstraintValue"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param inout name "resV" explicit_type "defaulttype::BaseVector"
	  param in name "" explicit_type "bool"
	    defaultvalue "true"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @deprecated use instead getConstraintViolation(defaulttype::BaseVector *, const DataVecCoord&, const DataVecDeriv&, const ConstraintParams*)"
      end

      operation 207152 "buildConstraintMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "cId" type class_ref 129072 // MultiMatrixDerivId
	  param inout name "cIndex" explicit_type "uint"
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} & ${p1}, const ${t2} * ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Construct the Jacobian Matrix
/
/ \\param cId is the result constraint sparse matrix Id
/ \\param cIndex is the index of the next constraint equation: when building the constraint matrix, you have to use this index, and then update it
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)"
      end

      operation 207280 "buildConstraintMatrix"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 4
	  param inout name "c" type class_ref 153904 // DataMatrixDeriv
	  param inout name "cIndex" explicit_type "uint"
	  param in name "x" type class_ref 153648 // DataVecCoord
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}, const ${t3} * ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Construct the Jacobian Matrix
/
/ \\param c is the result constraint sparse matrix
/ \\param cIndex is the index of the next constraint equation: when building the constraint matrix, you have to use this index, and then update it
/ \\param x is the position vector used for contraint equation computation
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)
/
/ This is the method that should be implemented by the component"
      end

      operation 207408 "canCreate"
	stereotype "template"
	class_operation cpp_inline public explicit_return_type "bool"
	nparams 3
	  param inout name "obj" explicit_type "T"
	  param inout name "context" type class_ref 141104 // BaseContext
	  param inout name "arg" type class_ref 141232 // BaseObjectDescription
	cpp_decl "    ${comment}template<class T>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * & ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        if (dynamic_cast<MechanicalState<DataTypes>*>(context->getMechanicalState()) == NULL)
            return false;
        return BaseObject::canCreate(obj, context, arg);
    };
"
	
	
	
	
	comment "/ Pre-construction check method called by ObjectFactory.
/ Check that DataTypes matches the MechanicalState."
      end

      operation 207536 "getTemplateName"
	const cpp_virtual cpp_inline public explicit_return_type "std::string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        return templateName(this);
    };
"
	
	
	
	
      end

      operation 207664 "templateName"
	class_operation cpp_inline public explicit_return_type "std::string"
	nparams 1
	  param in name "" type class_ref 152752 // Constraint
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return DataTypes::Name();
    };
"
	
	
	
	
      end

      attribute 142640 "mstate"
	protected explicit_type "DataTypes"
	stereotype "MechanicalState"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 154032 "MechanicalState"
      abstract visibility package 
      nformals 1
      formal name "DataTypes" type "class" explicit_default_value ""
        explicit_extends ""
      nactuals 1
      actual class class_ref 135856 // State
        rank 0 explicit_value "TDataTypes"
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component storing all state vectors of a simulated body (position,
 *  velocity, etc), using the datatype specified in the templace.
 *
 *  The given DataTypes class should define the following internal types:
 *  \\li \\code Real \\endcode : scalar values (float or double).
 *  \\li \\code Coord \\endcode : position values.
 *  \\li \\code Deriv \\endcode : derivative values (velocity, forces, displacements).
 *  \\li \\code VecReal \\endcode : container of scalar values with the same API as sofa::helper::vector.
 *  \\li \\code VecCoord \\endcode : container of Coord values with the same API as sofa::helper::vector.
 *  \\li \\code VecDeriv \\endcode : container of Deriv values with the same API as sofa::helper::vector.
 *  \\li \\code MatrixDeriv \\endcode : vector of constraints.
 *
 *  Other vectors can be allocated to store other temporary values.
 *  Vectors can be assigned efficiently by just swapping pointers.
 *
 *  In addition to state vectors, the current constraint system matrix is also
 *  stored, containing the coefficient of each constraint defined over the DOFs
 *  in this body.
 *"
      classrelation 147632 // <generalisation>
	relation 147632 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 147632 // <generalisation>
	  b parent class_ref 150064 // BaseMechanicalState
      end

      classrelation 147760 // <generalisation>
	relation 147760 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 147760 // <generalisation>
	  b parent class_ref 135856 // State
      end

      class 159664 "DataTypes"
	visibility package stereotype "typedef" explicit_base_type "TDataTypes"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 159792 "Real"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Real"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 159920 "Coord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 160048 "Deriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 160176 "VecReal"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecReal"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 160304 "VecCoord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 160432 "VecDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 160560 "MatrixDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::MatrixDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      operation 219824 "~MechanicalState"
	cpp_virtual cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} { };
"
	
	
	
	
      end

      operation 219952 "getXfree"
	const cpp_virtual cpp_inline public return_type class_ref 160304 // VecCoord
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        const Data<VecCoord>* v = this->read(ConstVecCoordId::freePosition());
        return (v == NULL) ? NULL : &(v->getValue());
    };
"
	
	
	
	
	comment "/ Return the current free-motion position vector.
/ @deprecated use readVecCoord(ConstVecCoordId::freePosition()) instead."
      end

      operation 220080 "getVfree"
	const cpp_virtual cpp_inline public return_type class_ref 160432 // VecDeriv
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {
		const Data<VecDeriv>* v = this->read(ConstVecDerivId::freeVelocity());
		return (v == NULL) ? NULL : &(v->getValue());
	};
"
	
	
	
	
	comment "/ Return the current free-motion velocity vector.
/ @deprecated use readVecDeriv(ConstVecDerivId::freeVelocity()) instead."
      end

      operation 220208 "getXReset"
	const cpp_virtual cpp_inline public return_type class_ref 160304 // VecCoord
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {
		const Data<VecCoord>* v = this->read(ConstVecCoordId::resetPosition());
		return (v == NULL) ? NULL : &(v->getValue());
	};
"
	
	
	
	
	comment "/ Return the current reset position vector.
/ (return NULL if the state does not store rest position).
/ @deprecated use readVecCoord(ConstVecCoordId::resetPosition()) instead."
      end

      operation 220336 "getF"
	const cpp_virtual cpp_inline public return_type class_ref 160432 // VecDeriv
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        const Data<VecDeriv>* v = this->read(ConstVecDerivId::force());
        return (v == NULL) ? NULL : &(v->getValue());
    };
"
	
	
	
	
	comment "/ Return the force vector.
/ @deprecated use readVecDeriv(ConstVecDerivId::force()) instead."
      end

      operation 220464 "getExternalForces"
	const cpp_virtual cpp_inline public return_type class_ref 160432 // VecDeriv
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        const Data<VecDeriv>* v = this->read(ConstVecDerivId::externalForce());
        return (v == NULL) ? NULL : &(v->getValue());
    };
"
	
	
	
	
	comment "/ Return the external forces vector.
/ @deprecated use readVecDeriv(ConstVecDerivId::externalForce()) instead."
      end

      operation 220592 "getDx"
	const cpp_virtual cpp_inline public return_type class_ref 160432 // VecDeriv
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        const Data<VecDeriv>* v = this->read(ConstVecDerivId::dx());
        return (v == NULL) ? NULL : &(v->getValue());
    };
"
	
	
	
	
	comment "/ Return the dx vector.
/ @deprecated use readVecDeriv(ConstVecDerivId::dx()) instead."
      end

      operation 220720 "getVReset"
	const cpp_virtual cpp_inline public return_type class_ref 160432 // VecDeriv
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        const Data<VecDeriv>* v = this->read(ConstVecDerivId::resetVelocity());
        return (v == NULL) ? NULL : &(v->getValue());
    };
"
	
	
	
	
	comment "/ Return the dx vector.
/ @deprecated use readVecDeriv(ConstVecDerivId::restVelocity()) instead."
      end

      operation 220848 "getC"
	const cpp_virtual cpp_inline public return_type class_ref 160560 // MatrixDeriv
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        const Data<MatrixDeriv>* v = this->read(ConstMatrixDerivId::holonomicC());
        return (v == NULL) ? NULL : &(v->getValue());
    };
"
	
	
	
	
	comment "/ Return the constraint sparse matrix.
/ @deprecated use readVecDeriv(ConstMatrixDerivId::holonomicC()) instead."
      end

      operation 220976 "getCoordDimension"
	const cpp_virtual cpp_inline public explicit_return_type "uint"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return defaulttype::DataTypeInfo<Coord>::size(); };
"
	
	
	
	
      end

      operation 221104 "getDerivDimension"
	const cpp_virtual cpp_inline public explicit_return_type "uint"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return defaulttype::DataTypeInfo<Deriv>::size(); };
"
	
	
	
	
      end

      operation 221232 "getIndicesInSpace"
	abstract const cpp_virtual public explicit_return_type "void"
	nparams 7
	  param inout name "" explicit_type "sofa::helper::vector<unsigned>"
	  param in name "" type class_ref 159792 // Real
	  param in name "" type class_ref 159792 // Real
	  param in name "" type class_ref 159792 // Real
	  param in name "" type class_ref 159792 // Real
	  param in name "" type class_ref 159792 // Real
	  param in name "" type class_ref 159792 // Real
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Get the indices of the particles located in the given bounding box"
      end

      operation 221360 "getTemplateName"
	const cpp_virtual cpp_inline public explicit_return_type "std::string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
      return templateName(this);
    };
"
	
	
	
	
      end

      operation 221488 "templateName"
	class_operation cpp_inline public explicit_return_type "std::string"
	nparams 1
	  param in name "" explicit_type "MechanicalState<DataTypes>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
      return DataTypes::Name();
    };
"
	
	
	
	
      end
    end

    class 154160 "ConstraintSolver"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component responsible for the expression and solution of system of equations related to constraints
 *"
      classrelation 145456 // <generalisation>
	relation 145456 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 145456 // <generalisation>
	  b parent class_ref 149424 // typedef7
      end

      classrelation 145584 // <generalisation>
	relation 145584 ---|>
	  a private
	    cpp default "${type}"
	    classrelation_ref 145584 // <generalisation>
	  b parent class_ref 128304 // BaseObject
      end

      class 154288 "ConstOrder"
	visibility package stereotype "typedef" base_type class_ref 133040 // ConstOrder
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 145712 // <dependency>
	  relation 145712 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 145712 // <dependency>
	    b parent class_ref 133040 // ConstOrder
	end
      end

      operation 207792 "ConstraintSolver"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 207920 "~ConstraintSolver"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 208048 "solveConstraint"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "dt" explicit_type "double"
	  param in name "id" type class_ref 140464 // MultiVecId
	  param in name "order" type class_ref 154288 // ConstOrder
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "* Launch the sequence of operations in order to solve the constraints
     * @param Id order of the constraint to be solved
     * @param isPositionChangesUpdateVelocity boolean indication if we need to propagate the change of position to a modification of velocity dv=dx/dt
     *"
      end

      operation 208176 "prepareStates"
	abstract cpp_virtual public explicit_return_type "bool"
	nparams 3
	  param in name "" explicit_type "double"
	  param in name "" type class_ref 140464 // MultiVecId
	  param in name "order" type class_ref 154288 // ConstOrder
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "* 
     * Do the precomputation: compute free state, or propagate the states to the mapped mechanical states, where the constraint can be expressed"
      end

      operation 208304 "buildSystem"
	abstract cpp_virtual public explicit_return_type "bool"
	nparams 3
	  param in name "" explicit_type "double"
	  param in name "" type class_ref 140464 // MultiVecId
	  param in name "order" type class_ref 154288 // ConstOrder
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "* 
     * Create the system corresponding to the constraints"
      end

      operation 208432 "solveSystem"
	abstract cpp_virtual public explicit_return_type "bool"
	nparams 3
	  param in name "" explicit_type "double"
	  param in name "" type class_ref 140464 // MultiVecId
	  param in name "order" type class_ref 154288 // ConstOrder
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "* 
     * Use the system previously built and solve it with the appropriate algorithm"
      end

      operation 208560 "applyCorrection"
	abstract cpp_virtual public explicit_return_type "bool"
	nparams 3
	  param in name "" explicit_type "double"
	  param in name "" type class_ref 140464 // MultiVecId
	  param in name "order" type class_ref 154288 // ConstOrder
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "* 
     * Correct the Mechanical State with the solution found"
      end
    end

    class 154416 "ForceField"
      abstract visibility package 
      nformals 1
      formal name "DataTypes" type "class" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component computing forces within a simulated body.
 *
 *  This class define the abstract API common to force fields using a
 *  given type of DOFs.
 *  A force field computes forces applied to one simulated body
 *  given its current position and velocity.
 *
 *  For implicit integration schemes, it must also compute the derivative
 *  ( df, given a displacement dx )."
      classrelation 145840 // <generalisation>
	relation 145840 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 145840 // <generalisation>
	  b parent class_ref 149680 // BaseForceField
      end

      class 154544 "DataTypes"
	visibility package stereotype "typedef" explicit_base_type "TDataTypes"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 154672 "Coord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 154800 "Deriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 154928 "VecCoord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 155056 "VecDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 155184 "DataVecCoord"
	visibility package stereotype "typedef" base_type class_ref 154928 // VecCoord
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 145968 // <dependency>
	  relation 145968 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 145968 // <dependency>
	    b parent class_ref 154928 // VecCoord
	end
      end

      class 155312 "DataVecDeriv"
	visibility package stereotype "typedef" base_type class_ref 155056 // VecDeriv
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 146096 // <dependency>
	  relation 146096 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 146096 // <dependency>
	    b parent class_ref 155056 // VecDeriv
	end
      end

      operation 208688 "ForceField"
	public explicit_return_type ""
	nparams 1
	  param inout name "mm" explicit_type "MechanicalState<DataTypes>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 208816 "~ForceField"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 208944 "init"
	cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 209072 "getMState"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 209200 "addForce"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "fId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @name Vector operations
/ @{
/ Given the current position and velocity states, update the current force
/ vector by computing and adding the forces associated with this
/ ForceField.
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ f += B v + K x $
/
/ This method retrieves the force, x and v vector from the MechanicalState
/ and call the internal addForce(DataVecDeriv&,const DataVecCoord&,const DataVecDeriv&, const MechanicalParams*)
/ method implemented by the component."
      end

      operation 209328 "addForce"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 4
	  param inout name "f" type class_ref 155312 // DataVecDeriv
	  param in name "x" type class_ref 155184 // DataVecCoord
	  param in name "v" type class_ref 155312 // DataVecDeriv
	  param in name "" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}, const ${t3} * ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Given the current position and velocity states, update the current force
/ vector by computing and adding the forces associated with this
/ ForceField.
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ f += B v + K x $
/
/ This is the method that should be implemented by the component"
      end

      operation 209456 "addForce"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "f" type class_ref 155056 // VecDeriv
	  param in name "x" type class_ref 154928 // VecCoord
	  param in name "v" type class_ref 155056 // VecDeriv
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, const ${t1} & ${p1}, const ${t2} & ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @deprecated use instead addForce(DataVecDeriv&,const DataVecCoord&,const DataVecDeriv&, const MechanicalParams*)"
      end

      operation 209584 "addDForce"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "dfId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Compute the force derivative given a small displacement from the
/ position and velocity used in the previous call to addForce().
/
/ The derivative should be directly derived from the computations
/ done by addForce. Any forces neglected in addDForce will be integrated
/ explicitly (i.e. using its value at the beginning of the timestep).
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ df += kFactor K dx + bFactor B dx $
/
/ This method retrieves the force and dx vector from the MechanicalState
/ and call the internal addDForce(VecDeriv&,const VecDeriv&,double,double)
/ method implemented by the component."
      end

      operation 209712 "addDForce"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "df" type class_ref 155312 // DataVecDeriv
	  param in name "dx" type class_ref 155312 // DataVecDeriv
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 209840 "addDForce"
	cpp_virtual public explicit_return_type "void"
	nparams 4
	  param inout name "df" type class_ref 155056 // VecDeriv
	  param in name "dx" type class_ref 155056 // VecDeriv
	  param in name "kFactor" explicit_type "double"
	  param in name "bFactor" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, const ${t1} & ${p1}, ${t2} ${p2}, ${t3} ${p3}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @deprecated"
      end

      operation 209968 "addDForce"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param inout name "df" type class_ref 155056 // VecDeriv
	  param in name "dx" type class_ref 155056 // VecDeriv
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @deprecated"
      end

      operation 210096 "getPotentialEnergy"
	const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Get the potential energy associated to this ForceField.
/
/ Used to extimate the total energy of the system by some
/ post-stabilization techniques.
/
/ This method must be implemented by the component, and is usually called
/ by the generic ForceField::getPotentialEnergy(const MechanicalParams* mparams) method."
      end

      operation 210224 "getPotentialEnergy"
	abstract const cpp_virtual public explicit_return_type "double"
	nparams 2
	  param in name "x" type class_ref 155184 // DataVecCoord
	  param in name "" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
      end

      operation 210352 "getPotentialEnergy"
	const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "x" type class_ref 154928 // VecCoord
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @deprecated"
      end

      operation 210480 "addKToMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "matrix" type class_ref 149808 // MultiMatrixAccessor
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @}
/ @name Matrix operations
/ @{"
      end

      operation 210608 "addKToMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "matrix" explicit_type "sofa::defaulttype::BaseMatrix"
	  param in name "kFact" explicit_type "double"
	  param inout name "offset" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}, ${t2} & ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @deprecated"
      end

      operation 210736 "addBToMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "matrix" type class_ref 149808 // MultiMatrixAccessor
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 210864 "addBToMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "matrix" explicit_type "sofa::defaulttype::BaseMatrix"
	  param in name "bFact" explicit_type "double"
	  param inout name "offset" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}, ${t2} & ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @deprecated"
      end

      operation 210992 "canCreate"
	stereotype "template"
	class_operation cpp_inline public explicit_return_type "bool"
	nparams 3
	  param inout name "obj" explicit_type "T"
	  param inout name "context" type class_ref 141104 // BaseContext
	  param inout name "arg" type class_ref 141232 // BaseObjectDescription
	cpp_decl "    ${comment}template<class T>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * & ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        if (dynamic_cast<MechanicalState<DataTypes>*>(context->getMechanicalState()) == NULL)
            return false;
        return BaseObject::canCreate(obj, context, arg);
    };
"
	
	
	
	
	comment "/ @}
/ Pre-construction check method called by ObjectFactory.
/ Check that DataTypes matches the MechanicalState."
      end

      operation 211120 "getTemplateName"
	const cpp_virtual cpp_inline public explicit_return_type "std::string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        return templateName(this);
    };
"
	
	
	
	
      end

      operation 211248 "templateName"
	class_operation cpp_inline public explicit_return_type "std::string"
	nparams 1
	  param in name "" explicit_type "ForceField<DataTypes>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return DataTypes::Name();
    };
"
	
	
	
	
      end

      attribute 142768 "mstate"
	protected explicit_type "DataTypes"
	stereotype "MechanicalState"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 155440 "LinearSolver"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Abstract interface for linear system solvers
 *"
      classrelation 146224 // <generalisation>
	relation 146224 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 146224 // <generalisation>
	  b parent class_ref 149424 // typedef7
      end

      classrelation 146352 // <generalisation>
	relation 146352 ---|>
	  a private
	    cpp default "${type}"
	    classrelation_ref 146352 // <generalisation>
	  b parent class_ref 128304 // BaseObject
      end

      operation 211376 "LinearSolver"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}
: frozen(false)
${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 211504 "~LinearSolver"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 211632 "resetSystem"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Reset the current linear system."
      end

      operation 211760 "setSystemMBKMatrix"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Set the linear system matrix, combining the mechanical M,B,K matrices using the given coefficients
/
/ @todo Should we put this method in a specialized class for mechanical systems, or express it using more general terms (i.e. coefficients of the second order ODE to solve)"
      end

      operation 211888 "setSystemRHVector"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "v" type class_ref 128816 // MultiVecDerivId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Set the linear system right-hand term vector, from the values contained in the (Mechanical/Physical)State objects"
      end

      operation 212016 "setSystemLHVector"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "v" type class_ref 128816 // MultiVecDerivId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Set the initial estimate of the linear system left-hand term vector, from the values contained in the (Mechanical/Physical)State objects
/ This vector will be replaced by the solution of the system once solveSystem is called"
      end

      operation 212144 "solveSystem"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Solve the system as constructed using the previous methods"
      end

      operation 212272 "partial_solve"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 3
	  param inout name "" explicit_type "std::list<int>"
	  param inout name "" explicit_type "std::list<int>"
	  param in name "" explicit_type "bool"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {serr<<\"WARNING : partial_solve is not implemented yet\"<<sendl; };
"
	
	
	
	
	comment "/"
      end

      operation 212400 "invertSystem"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {};
"
	
	
	
	
	comment "/ Invert the system, this method is optional because it's called when solveSystem() is called for the first time"
      end

      operation 212528 "addMInvJt"
	cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 3
	  param inout name "" explicit_type "defaulttype::BaseMatrix"
	  param inout name "" explicit_type "defaulttype::BaseMatrix"
	  param in name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        return false;
    };
"
	
	
	
	
	comment "/ Multiply the inverse of the system matrix by the transpose of the given matrix J
/
/ @param result the variable where the result will be added
/ @param J the matrix J to use
/ @return false if the solver does not support this operation, of it the system matrix is not invertible"
      end

      operation 212656 "addJMInvJt"
	cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 3
	  param inout name "" explicit_type "defaulttype::BaseMatrix"
	  param inout name "" explicit_type "defaulttype::BaseMatrix"
	  param in name "" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        return false;
    };
"
	
	
	
	
	comment "/ Multiply the inverse of the system matrix by the transpose of the given matrix, and multiply the result with the given matrix J
/
/ @param result the variable where the result will be added
/ @param J the matrix J to use
/ @return false if the solver does not support this operation, of it the system matrix is not invertible"
      end

      operation 212784 "getSystemBaseMatrix"
	cpp_virtual cpp_inline public explicit_return_type "defaulttype::BaseMatrix"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return NULL; };
"
	
	
	
	
	comment "/ Get the linear system matrix, or NULL if this solver does not build it"
      end

      operation 212912 "getSystemRHBaseVector"
	cpp_virtual cpp_inline public explicit_return_type "defaulttype::BaseVector"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return NULL; };
"
	
	
	
	
	comment "/ Get the linear system right-hand term vector, or NULL if this solver does not build it"
      end

      operation 213040 "getSystemLHBaseVector"
	cpp_virtual cpp_inline public explicit_return_type "defaulttype::BaseVector"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return NULL; };
"
	
	
	
	
	comment "/ Get the linear system left-hand term vector, or NULL if this solver does not build it"
      end

      operation 213168 "getSystemInverseBaseMatrix"
	cpp_virtual cpp_inline public explicit_return_type "defaulttype::BaseMatrix"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return NULL; };
"
	
	
	
	
	comment "/ Get the linear system inverse matrix, or NULL if this solver does not build it"
      end

      operation 213296 "readFile"
	cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 1
	  param inout name "" explicit_type "std::istream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return false;};
"
	
	
	
	
	comment "/ Read the Matrix solver from a file"
      end

      operation 213424 "writeFile"
	cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 1
	  param inout name "" explicit_type "std::ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {return false;};
"
	
	
	
	
	comment "/ Read the Matrix solver from a file"
      end

      operation 213552 "freezeSystemMatrix"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { frozen = true; };
"
	
	
	
	
	comment "/ Ask the solver to no longer update the system matrix"
      end

      operation 213680 "updateSystemMatrix"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { frozen = false; };
"
	
	
	
	
	comment "/ Ask the solver to no update the system matrix at the next iteration"
      end

      operation 213808 "isMultiGroup"
	const cpp_virtual cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        return false;
    };
"
	
	
	
	
	comment "/ Check if this solver handle multiple multiple independent integration groups, placed as child nodes in the scene graph.
/
/ If this is the case, then when collisions occur, the CollisionGroupManager can simply group the interacting groups into new child nodes without creating a new solver to handle them."
      end

      attribute 142896 "frozen"
	protected explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 155568 "LMConstraint"
      visibility package 
      nformals 2
      formal name "DataTypes1" type "class" explicit_default_value ""
        explicit_extends ""
      formal name "DataTypes2" type "class" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
	 *  \\brief Component computing constraints within a simulated body.
	 *
	 *  This class define the abstract API common to constraints using a given type
	 *  of DOFs.
	 *  A LMConstraint computes complex constraints applied to two bodies
	 *"
      classrelation 146480 // <generalisation>
	relation 146480 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 146480 // <generalisation>
	  b parent class_ref 151216 // BaseLMConstraint
      end

      class 155696 "Real1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::Real"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 155824 "VecCoord1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 155952 "VecDeriv1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 156080 "Coord1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 156208 "Deriv1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 156336 "MatrixDeriv1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::MatrixDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 156464 "MatrixDeriv1RowConstIterator"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::MatrixDeriv::RowConstIterator"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 156592 "MatrixDeriv1ColConstIterator"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::MatrixDeriv::ColConstIterator"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 156720 "MatrixDeriv1RowIterator"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::MatrixDeriv::RowIterator"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 156848 "MatrixDeriv1ColIterator"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::MatrixDeriv::ColIterator"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 156976 "MatrixDerivRowType1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::MatrixDeriv::RowType"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 157104 "Real2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::Real"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 157232 "VecCoord2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 157360 "VecDeriv2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 157488 "Coord2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 157616 "Deriv2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 157744 "MatrixDeriv2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::MatrixDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 157872 "MatrixDeriv2RowConstIterator"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::MatrixDeriv::RowConstIterator"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 158000 "MatrixDeriv2ColConstIterator"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::MatrixDeriv::ColConstIterator"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 158128 "MatrixDeriv2RowIterator"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::MatrixDeriv::RowIterator"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 158256 "MatrixDeriv2ColIterator"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::MatrixDeriv::ColIterator"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 158384 "MatrixDerivRowType2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::MatrixDeriv::RowType"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      operation 213936 "LMConstraint"
	cpp_inline public explicit_return_type ""
	nparams 2
	  param inout name "dof1" explicit_type "MechanicalState<DataTypes1>"
	  param inout name "dof2" explicit_type "MechanicalState<DataTypes2>"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, ${t1} * ${p1}${v1}${)}${volatile}${throw} : constrainedObject1(dof1)
		, constrainedObject2(dof2)
		, simulatedObject1(dof1)
		, simulatedObject2(dof2)
	{
	
	};
"
	
	
	
	
      end

      operation 214064 "LMConstraint"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} : constrainedObject1(NULL)
		, constrainedObject2(NULL)
		, simulatedObject1(NULL)
		, simulatedObject2(NULL)
	{
	
	};
"
	
	
	
	
      end

      operation 214192 "~LMConstraint"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 214320 "init"
	cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 214448 "getConstrainedMechModel1"
	const cpp_virtual cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {return constrainedObject1;};
"
	
	
	
	
	comment "/ get Mechanical State 1 where the constraint will be expressed (can be a Mapped mechanical state)"
      end

      operation 214576 "getConstrainedMechModel2"
	const cpp_virtual cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {return constrainedObject2;};
"
	
	
	
	
	comment "/ get Mechanical State 2 where the constraint will be expressed (can be a Mapped mechanical state)"
      end

      operation 214704 "getSimulatedMechModel1"
	const cpp_virtual cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {return simulatedObject1;};
"
	
	
	
	
	comment "/ get Mechanical State 1 where the constraint will be solved"
      end

      operation 214832 "getSimulatedMechModel2"
	const cpp_virtual cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {return simulatedObject2;};
"
	
	
	
	
	comment "/ get Mechanical State 2 where the constraint will be solved"
      end

      operation 214960 "canCreate"
	stereotype "template"
	class_operation cpp_inline public explicit_return_type "bool"
	nparams 3
	  param inout name "obj" explicit_type "T"
	  param inout name "context" type class_ref 141104 // BaseContext
	  param inout name "arg" type class_ref 141232 // BaseObjectDescription
	cpp_decl "    ${comment}template<class T>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * & ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
		if (arg->getAttribute(\"object1\") || arg->getAttribute(\"object2\"))
		{
			if (dynamic_cast<MechanicalState<DataTypes1>*>(arg->findObject(arg->getAttribute(\"object1\",\"..\"))) == NULL)
				return false;
			if (dynamic_cast<MechanicalState<DataTypes2>*>(arg->findObject(arg->getAttribute(\"object2\",\"..\"))) == NULL)
				return false;
		}
		else
		{
			if (dynamic_cast<MechanicalState<DataTypes1>*>(context->getMechanicalState()) == NULL)
				return false;
		}
		return sofa::core::objectmodel::BaseObject::canCreate(obj, context, arg);
	};
"
	
	
	
	
	comment "/ Pre-construction check method called by ObjectFactory."
      end

      operation 215088 "create"
	stereotype "template"
	class_operation cpp_inline public explicit_return_type "void"
	nparams 3
	  param inout name "obj" explicit_type "T"
	  param inout name "context" type class_ref 141104 // BaseContext
	  param inout name "arg" type class_ref 141232 // BaseObjectDescription
	cpp_decl "    ${comment}template<class T>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * & ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
		sofa::core::objectmodel::BaseObject::create(obj, context, arg);
		if (arg && (arg->getAttribute(\"object1\") || arg->getAttribute(\"object2\")))
		{
			obj->constrainedObject1 = dynamic_cast<MechanicalState<DataTypes1>*>(arg->findObject(arg->getAttribute(\"object1\",\"..\")));
			obj->constrainedObject2 = dynamic_cast<MechanicalState<DataTypes2>*>(arg->findObject(arg->getAttribute(\"object2\",\"..\")));
		}
		else if (context)
		{
			obj->constrainedObject1 =
			obj->constrainedObject2 =
			dynamic_cast<MechanicalState<DataTypes1>*>(context->getMechanicalState());
		}
	};
"
	
	
	
	
	comment "/ Construction method called by ObjectFactory."
      end

      operation 215216 "getTemplateName"
	const cpp_virtual cpp_inline public explicit_return_type "std::string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
		return templateName(this);
	};
"
	
	
	
	
      end

      operation 215344 "templateName"
	class_operation cpp_inline public explicit_return_type "std::string"
	nparams 1
	  param in name "" type class_ref 155568 // LMConstraint
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return DataTypes1::Name() + std::string(\",\") + DataTypes2::Name();
	};
"
	
	
	
	
      end

      attribute 143024 "constrainedObject1"
	protected explicit_type "DataTypes1"
	stereotype "MechanicalState"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 143152 "constrainedObject2"
	protected explicit_type "DataTypes2"
	stereotype "MechanicalState"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      classrelation 146608 // simulatedObject1 (<unidirectional association>)
	relation 146608 --->
	  a role_name "simulatedObject1" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 146608 // simulatedObject1 (<unidirectional association>)
	  b parent class_ref 150064 // BaseMechanicalState
      end

      classrelation 146736 // simulatedObject2 (<unidirectional association>)
	relation 146736 --->
	  a role_name "simulatedObject2" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 146736 // simulatedObject2 (<unidirectional association>)
	  b parent class_ref 150064 // BaseMechanicalState
      end
    end

    class 158512 "Mass"
      abstract visibility package 
      nformals 1
      formal name "DataTypes" type "class" explicit_default_value ""
        explicit_extends ""
      nactuals 1
      actual class class_ref 154416 // ForceField
        rank 0 explicit_value "DataTypes"
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component responsible for mass-related computations (gravity, acceleration).
 *
 *  Mass can be defined either as a scalar, vector, or a full mass-matrix.
 *  It is responsible for converting forces to accelerations (for explicit integrators),
 *  or displacements to forces (for implicit integrators).
 *
 *  It is also a ForceField, computing gravity-related forces."
      classrelation 146864 // <generalisation>
	relation 146864 ---|>
	  a public
	    cpp virtual default "${type}"
	    classrelation_ref 146864 // <generalisation>
	  b parent class_ref 154416 // ForceField
      end

      classrelation 146992 // <generalisation>
	relation 146992 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 146992 // <generalisation>
	  b parent class_ref 151472 // BaseMass
      end

      class 158640 "VecCoord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 158768 "VecDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 158896 "DataVecCoord"
	visibility package stereotype "typedef" base_type class_ref 158640 // VecCoord
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 147120 // <dependency>
	  relation 147120 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 147120 // <dependency>
	    b parent class_ref 158640 // VecCoord
	end
      end

      class 159024 "DataVecDeriv"
	visibility package stereotype "typedef" base_type class_ref 158768 // VecDeriv
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 147248 // <dependency>
	  relation 147248 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 147248 // <dependency>
	    b parent class_ref 158768 // VecDeriv
	end
      end

      class 159152 "Coord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 159280 "Deriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 159408 "MatrixDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::MatrixDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      operation 215472 "Mass"
	public explicit_return_type ""
	nparams 1
	  param inout name "mm" explicit_type "MechanicalState<DataTypes>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 215600 "~Mass"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 215728 "init"
	cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 215856 "getMState"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return this->mstate; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 215984 "addMDx"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "fid" type class_ref 128816 // MultiVecDerivId
	  param in name "factor" explicit_type "double"
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, const ${t2} * ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @name Vector operations
/ @{
/                         $ f += factor M dx $
/
/ This method retrieves the force and dx vector and call the internal
/ addMDx(DataVecDeriv&, const DataVecDeriv&, double, const MechanicalParams*) method implemented by the component."
      end

      operation 216112 "addMDx"
	cpp_virtual public explicit_return_type "void"
	nparams 4
	  param inout name "f" type class_ref 159024 // DataVecDeriv
	  param in name "dx" type class_ref 159024 // DataVecDeriv
	  param in name "factor" explicit_type "double"
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}, const ${t3} * ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, const ${t1} & ${p1}, ${t2} ${p2}, const ${t3} * ${p3}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 216240 "addMDx"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "f" type class_ref 158768 // VecDeriv
	  param in name "dx" type class_ref 158768 // VecDeriv
	  param in name "factor" explicit_type "double"
	    defaultvalue "1.0"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, const ${t1} & ${p1}, ${t2} ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @deprecated"
      end

      operation 216368 "accFromF"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "aid" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/                            $ dx = M^-1 f $
/
/ This method retrieves the force and dx vector and call the internal
/ accFromF(VecDeriv&,const VecDeriv&) method implemented by the component."
      end

      operation 216496 "accFromF"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "a" type class_ref 159024 // DataVecDeriv
	  param in name "f" type class_ref 159024 // DataVecDeriv
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, const ${t1} & ${p1}, const ${t2} * ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 216624 "accFromF"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param inout name "a" type class_ref 158768 // VecDeriv
	  param in name "f" type class_ref 158768 // VecDeriv
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @deprecated"
      end

      operation 216752 "addDForce"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "" type class_ref 159024 // DataVecDeriv
	  param in name "" type class_ref 159024 // DataVecDeriv
	  param in name "" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, const ${t1} & ${p1}, const ${t2} * ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Mass forces (gravity) often have null derivative"
      end

      operation 216880 "addMBKdx"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "dfId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Accumulate the contribution of M, B, and/or K matrices multiplied
/ by the dx vector with the given coefficients.
/
/ This method computes
/ $ df += mFactor M dx + bFactor B dx + kFactor K dx $
/ For masses, it calls both addMdx and addDForce (which is often empty).
/
/ \\param mFact coefficient for mass contributions (i.e. second-order derivatives term in the ODE)
/ \\param bFact coefficient for damping contributions (i.e. first derivatives term in the ODE)
/ \\param kFact coefficient for stiffness contributions (i.e. DOFs term in the ODE)"
      end

      operation 217008 "getKineticEnergy"
	const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "virtual void addMBKdx(double mFactor, double bFactor, double kFactor);
/                         $ e = 1/2  v^t M v $
/
/ This method retrieves the velocity vector and call the internal
/ getKineticEnergy(const DataVecDeriv&, const MechanicalParams*) method implemented by the component."
      end

      operation 217136 "getKineticEnergy"
	const cpp_virtual public explicit_return_type "double"
	nparams 2
	  param in name "v" type class_ref 159024 // DataVecDeriv
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 217264 "getKineticEnergy"
	const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "v" type class_ref 158768 // VecDeriv
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @deprecated"
      end

      operation 217392 "getPotentialEnergy"
	const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/                         $ e = M g x $
/
/ This method retrieves the positions vector and call the internal
/ getPotentialEnergy(const VecCoord&, const MechanicalParams*) method implemented by the component."
      end

      operation 217520 "getPotentialEnergy"
	const cpp_virtual public explicit_return_type "double"
	nparams 2
	  param in name "x" type class_ref 158896 // DataVecCoord
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 217648 "getPotentialEnergy"
	const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "x" type class_ref 158640 // VecCoord
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @deprecated"
      end

      operation 217776 "addKToMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "matrix" type class_ref 149808 // MultiMatrixAccessor
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @}
/ @name Matrix operations
/ @{
/ @deprecated"
      end

      operation 217904 "addBToMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "matrix" type class_ref 149808 // MultiMatrixAccessor
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "virtual void addKToMatrix(sofa::defaulttype::BaseMatrix * matrix, double kFact, unsigned int &offset);"
      end

      operation 218032 "addMToMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "matrix" explicit_type "sofa::defaulttype::BaseMatrix"
	  param in name "mFact" explicit_type "double"
	  param inout name "offset" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}, ${t2} & ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @deprecated"
      end

      operation 218160 "addMToMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "matrix" type class_ref 149808 // MultiMatrixAccessor
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 218288 "addMBKToMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "matrix" type class_ref 149808 // MultiMatrixAccessor
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Compute the system matrix corresponding to m M + b B + k K
/
/ \\param matrix matrix to add the result to
/ \\param mFact coefficient for mass contributions (i.e. second-order derivatives term in the ODE)
/ \\param bFact coefficient for damping contributions (i.e. first derivatives term in the ODE)
/ \\param kFact coefficient for stiffness contributions (i.e. DOFs term in the ODE)"
      end

      operation 218416 "initGnuplot"
	cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "path" explicit_type "std::string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "virtual void addMBKToMatrix(const sofa::core::behavior::MultiMatrixAccessor* matrix, double mFact, double bFact, double kFact);
virtual void addMBKToMatrix(sofa::defaulttype::BaseMatrix * matrix, double mFact, double bFact, double kFact, unsigned int &offset);
/ @}
/ initialization to export kinetic and potential energy to gnuplot files format"
      end

      operation 218544 "exportGnuplot"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "time" explicit_type "double"
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	    defaultvalue "MechanicalParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ export kinetic and potential energy state at \"time\" to a gnuplot file"
      end

      operation 218672 "addGravityToV"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ perform  v += dt*g operation. Used if mass wants to added G separately from the other forces to v."
      end

      operation 218800 "addGravityToV"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param inout name "" type class_ref 159024 // DataVecDeriv
	  param in name "" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} { };
"
	
	
	
	
      end

      operation 218928 "getElementMass"
	const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "" explicit_type "uint"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "virtual void addGravityToV(double dt)=0;"
      end

      operation 219056 "getElementMass"
	const cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "index" explicit_type "uint"
	  param inout name "m" explicit_type "defaulttype::BaseMatrix"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      attribute 143280 "m_gnuplotFileEnergy"
	protected explicit_type "std::ofstream"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 159536 "MasterSolver"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component responsible for main simulation algorithms, managing how
 *  and when collisions and integrations computations happen.
 *
 *  This class can optionally replace the default computation scheme of computing
 *  collisions then doing an integration step.
 *
 *  Note that it is in a preliminary stage, hence its fonctionnalities and API will
 *  certainly change soon.
 *"
      classrelation 147376 // <generalisation>
	relation 147376 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 147376 // <generalisation>
	  b parent class_ref 149424 // typedef7
      end

      classrelation 147504 // <generalisation>
	relation 147504 ---|>
	  a private
	    cpp default "${type}"
	    classrelation_ref 147504 // <generalisation>
	  b parent class_ref 128304 // BaseObject
      end

      operation 219184 "MasterSolver"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 219312 "~MasterSolver"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 219440 "step"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "dt" explicit_type "double"
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Main computation method.
/
/ Specify and execute all computations for computing a timestep, such
/ as one or more collisions and integrations stages."
      end

      operation 219568 "computeCollision"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @name Visitors
/ These methods provides an abstract view of the mechanical system to animate.
/ They are implemented by executing Visitors in the subtree of the scene-graph below this solver.
/ @{
/ Activate collision pipeline"
      end

      operation 219696 "integrate"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "dt" explicit_type "double"
	  param in name "params" type class_ref 132912 // ExecParams
	    defaultvalue "ExecParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Activate OdeSolvers"
      end
    end

    class 160688 "MixedInteractionConstraint"
      abstract visibility package 
      nformals 2
      formal name "TDataTypes1" type "class" explicit_default_value ""
        explicit_extends ""
      formal name "TDataTypes2" type "class" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component computing constraints between a pair of simulated body.
 *
 *  This class define the abstract API common to interaction constraints
 *  between a pair of bodies using a given type of DOFs."
      classrelation 147888 // <generalisation>
	relation 147888 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 147888 // <generalisation>
	  b parent class_ref 149936 // BaseInteractionConstraint
      end

      class 160816 "DataTypes1"
	visibility package stereotype "typedef" explicit_base_type "TDataTypes1"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 160944 "VecCoord1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 161072 "VecDeriv1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 161200 "MatrixDeriv1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::MatrixDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 161328 "Coord1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 161456 "Deriv1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 161584 "DataTypes2"
	visibility package stereotype "typedef" explicit_base_type "TDataTypes2"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 161712 "VecCoord2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 161840 "VecDeriv2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 161968 "MatrixDeriv2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::MatrixDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 162096 "Coord2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 162224 "Deriv2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 162352 "ParticleMask"
	visibility package stereotype "typedef" explicit_base_type "helper::ParticleMask"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 162480 "DataVecCoord1"
	visibility package stereotype "typedef" base_type class_ref 160944 // VecCoord1
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 148016 // <dependency>
	  relation 148016 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 148016 // <dependency>
	    b parent class_ref 160944 // VecCoord1
	end
      end

      class 162608 "DataVecDeriv1"
	visibility package stereotype "typedef" base_type class_ref 161072 // VecDeriv1
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 148144 // <dependency>
	  relation 148144 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 148144 // <dependency>
	    b parent class_ref 161072 // VecDeriv1
	end
      end

      class 162736 "DataMatrixDeriv1"
	visibility package stereotype "typedef" base_type class_ref 161200 // MatrixDeriv1
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 148272 // <dependency>
	  relation 148272 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 148272 // <dependency>
	    b parent class_ref 161200 // MatrixDeriv1
	end
      end

      class 162864 "DataVecCoord2"
	visibility package stereotype "typedef" base_type class_ref 161712 // VecCoord2
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 148400 // <dependency>
	  relation 148400 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 148400 // <dependency>
	    b parent class_ref 161712 // VecCoord2
	end
      end

      class 162992 "DataVecDeriv2"
	visibility package stereotype "typedef" base_type class_ref 161840 // VecDeriv2
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 148528 // <dependency>
	  relation 148528 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 148528 // <dependency>
	    b parent class_ref 161840 // VecDeriv2
	end
      end

      class 163120 "DataMatrixDeriv2"
	visibility package stereotype "typedef" base_type class_ref 161968 // MatrixDeriv2
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 148656 // <dependency>
	  relation 148656 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 148656 // <dependency>
	    b parent class_ref 161968 // MatrixDeriv2
	end
      end

      operation 221616 "MixedInteractionConstraint"
	public explicit_return_type ""
	nparams 2
	  param inout name "mm1" explicit_type "MechanicalState<DataTypes1>"
	    defaultvalue "NULL"
	  param inout name "mm2" explicit_type "MechanicalState<DataTypes2>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, ${t1} * ${p1}${v1}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}, ${t1} * ${p1}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 221744 "~MixedInteractionConstraint"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      attribute 143408 "endTime"
	public explicit_type "double"
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "/< Time when the constraint becomes inactive (-1 for infinitely active)"
      end

      operation 221872 "isActive"
	const cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 222000 "init"
	cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/< if false, the constraint does nothing"
      end

      operation 222128 "getMState1"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes1>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate1; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 222256 "getMechModel1"
	cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate1; };
"
	
	
	
	
      end

      operation 222384 "getMState2"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes2>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate2; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 222512 "getMechModel2"
	cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate2; };
"
	
	
	
	
      end

      operation 222640 "getConstraintViolation"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param inout name "v" explicit_type "defaulttype::BaseVector"
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Construct the Constraint violations vector of each constraint
/
/ \\param v is the result vector that contains the whole constraints violations
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)"
      end

      operation 222768 "getConstraintViolation"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 6
	  param inout name "v" explicit_type "defaulttype::BaseVector"
	  param in name "x1" type class_ref 162480 // DataVecCoord1
	  param in name "x2" type class_ref 162864 // DataVecCoord2
	  param in name "v1" type class_ref 162608 // DataVecDeriv1
	  param in name "v2" type class_ref 162992 // DataVecDeriv2
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}, const ${t3} & ${p3}${v3}, const ${t4} & ${p4}${v4}, const ${t5} * ${p5}${v5}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Construct the Constraint violations vector of each constraint
/
/ \\param v is the result vector that contains the whole constraints violations
/ \\param x1 and x2 are the position vectors used to compute contraint position violation
/ \\param v1 and v2 are the velocity vectors used to compute contraint velocity violation
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)
/
/ This is the method that should be implemented by the component"
      end

      operation 222896 "buildConstraintMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "cId" type class_ref 129072 // MultiMatrixDerivId
	  param inout name "cIndex" explicit_type "uint"
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} & ${p1}, const ${t2} * ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Construct the Jacobian Matrix
/
/ \\param cId is the result constraint sparse matrix Id
/ \\param cIndex is the index of the next constraint equation: when building the constraint matrix, you have to use this index, and then update it
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)"
      end

      operation 223024 "buildConstraintMatrix"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 6
	  param inout name "c1" type class_ref 162736 // DataMatrixDeriv1
	  param inout name "c2" type class_ref 163120 // DataMatrixDeriv2
	  param inout name "cIndex" explicit_type "uint"
	  param in name "x1" type class_ref 162480 // DataVecCoord1
	  param in name "x2" type class_ref 162864 // DataVecCoord2
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}, const ${t3} & ${p3}${v3}, const ${t4} & ${p4}${v4}, const ${t5} * ${p5}${v5}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Construct the Jacobian Matrix
/
/ \\param c1 and c2 are the results constraint sparse matrix
/ \\param cIndex is the index of the next constraint equation: when building the constraint matrix, you have to use this index, and then update it
/ \\param x1 and x2 are the position vectors used for contraint equation computation
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)
/
/ This is the method that should be implemented by the component"
      end

      operation 223152 "canCreate"
	stereotype "template"
	class_operation cpp_inline public explicit_return_type "bool"
	nparams 3
	  param inout name "obj" explicit_type "T"
	  param inout name "context" type class_ref 141104 // BaseContext
	  param inout name "arg" type class_ref 141232 // BaseObjectDescription
	cpp_decl "    ${comment}template<class T>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * & ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        if (arg->getAttribute(\"object1\") || arg->getAttribute(\"object2\"))
        {
            if (dynamic_cast<MechanicalState<DataTypes1>*>(arg->findObject(arg->getAttribute(\"object1\",\"..\"))) == NULL)
                return false;
            if (dynamic_cast<MechanicalState<DataTypes2>*>(arg->findObject(arg->getAttribute(\"object2\",\"..\"))) == NULL)
                return false;
        }
        return BaseInteractionConstraint::canCreate(obj, context, arg);
    };
"
	
	
	
	
	comment "/ Pre-construction check method called by ObjectFactory.
/ Check that DataTypes matches the MechanicalState."
      end

      operation 223280 "create"
	stereotype "template"
	class_operation cpp_inline public explicit_return_type "void"
	nparams 3
	  param inout name "obj" explicit_type "T"
	  param inout name "context" type class_ref 141104 // BaseContext
	  param inout name "arg" type class_ref 141232 // BaseObjectDescription
	cpp_decl "    ${comment}template<class T>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * & ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        core::behavior::BaseInteractionConstraint::create(obj, context, arg);
        if (arg && (arg->getAttribute(\"object1\") || arg->getAttribute(\"object2\")))
        {
            obj->mstate1 = dynamic_cast<MechanicalState<DataTypes1>*>(arg->findObject(arg->getAttribute(\"object1\",\"..\")));
            obj->mstate2 = dynamic_cast<MechanicalState<DataTypes2>*>(arg->findObject(arg->getAttribute(\"object2\",\"..\")));
        }
    };
"
	
	
	
	
	comment "/ Construction method called by ObjectFactory."
      end

      operation 223408 "getTemplateName"
	const cpp_virtual cpp_inline public explicit_return_type "std::string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        return templateName(this);
    };
"
	
	
	
	
      end

      operation 223536 "templateName"
	class_operation cpp_inline public explicit_return_type "std::string"
	nparams 1
	  param in name "" explicit_type "MixedInteractionConstraint<DataTypes1,DataTypes2>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return DataTypes1::Name();
    };
"
	
	
	
	
      end

      attribute 143536 "object1"
	protected explicit_type " std::string "
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 143664 "object2"
	protected explicit_type " std::string "
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 143792 "mstate1"
	protected explicit_type "DataTypes1"
	stereotype "MechanicalState"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 143920 "mstate2"
	protected explicit_type "DataTypes2"
	stereotype "MechanicalState"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      classrelation 148784 // mask1 (<unidirectional association>)
	relation 148784 --->
	  a role_name "mask1" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 148784 // mask1 (<unidirectional association>)
	  b parent class_ref 162352 // ParticleMask
      end

      classrelation 148912 // mask2 (<unidirectional association>)
	relation 148912 --->
	  a role_name "mask2" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 148912 // mask2 (<unidirectional association>)
	  b parent class_ref 162352 // ParticleMask
      end
    end

    class 163248 "MixedInteractionForceField"
      abstract visibility package 
      nformals 2
      formal name "DataTypes1" type "class" explicit_default_value ""
        explicit_extends ""
      formal name "DataTypes2" type "class" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component computing forces between a pair of simulated body.
 *
 *  This class define the abstract API common to interaction force fields
 *  between a pair of bodies using a given type of DOFs."
      classrelation 149040 // <generalisation>
	relation 149040 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 149040 // <generalisation>
	  b parent class_ref 150192 // BaseInteractionForceField
      end

      class 163376 "DataTypes1"
	visibility package stereotype "typedef" explicit_base_type "TDataTypes1"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 163504 "VecCoord1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 163632 "VecDeriv1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 163760 "Coord1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 163888 "Deriv1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 164016 "Real1"
	visibility package stereotype "typedef" explicit_base_type "DataTypes1::Real"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 164144 "DataTypes2"
	visibility package stereotype "typedef" explicit_base_type "TDataTypes2"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 164272 "VecCoord2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 164400 "VecDeriv2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 164528 "Coord2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 164656 "Deriv2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 164784 "Real2"
	visibility package stereotype "typedef" explicit_base_type "DataTypes2::Real"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 164912 "ParticleMask"
	visibility package stereotype "typedef" explicit_base_type "helper::ParticleMask"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 165040 "DataVecCoord1"
	visibility package stereotype "typedef" base_type class_ref 163504 // VecCoord1
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 149168 // <dependency>
	  relation 149168 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 149168 // <dependency>
	    b parent class_ref 163504 // VecCoord1
	end
      end

      class 165168 "DataVecDeriv1"
	visibility package stereotype "typedef" base_type class_ref 163632 // VecDeriv1
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 149296 // <dependency>
	  relation 149296 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 149296 // <dependency>
	    b parent class_ref 163632 // VecDeriv1
	end
      end

      class 165296 "DataVecCoord2"
	visibility package stereotype "typedef" base_type class_ref 164272 // VecCoord2
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 149424 // <dependency>
	  relation 149424 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 149424 // <dependency>
	    b parent class_ref 164272 // VecCoord2
	end
      end

      class 165424 "DataVecDeriv2"
	visibility package stereotype "typedef" base_type class_ref 164400 // VecDeriv2
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 149552 // <dependency>
	  relation 149552 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 149552 // <dependency>
	    b parent class_ref 164400 // VecDeriv2
	end
      end

      operation 223664 "MixedInteractionForceField"
	public explicit_return_type ""
	nparams 2
	  param inout name "mm1" explicit_type "MechanicalState<DataTypes1>"
	    defaultvalue "NULL"
	  param inout name "mm2" explicit_type "MechanicalState<DataTypes2>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, ${t1} * ${p1}${v1}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}, ${t1} * ${p1}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 223792 "~MixedInteractionForceField"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 223920 "init"
	cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 224048 "getMState1"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes1>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate1; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 224176 "getMechModel1"
	cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate1; };
"
	
	
	
	
      end

      operation 224304 "getMState2"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes2>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate2; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 224432 "getMechModel2"
	cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate2; };
"
	
	
	
	
      end

      operation 224560 "addForce"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "fId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @name Vector operations
/ @{
/ Given the current position and velocity states, update the current force
/ vector by computing and adding the forces associated with this
/ ForceField.
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ f += B v + K x $
/
/ This method retrieves the force, x and v vector from the two MechanicalState
/ and call the internal addForce(VecDeriv&,VecDeriv&,const VecCoord&,const VecCoord&,const VecDeriv&,const VecDeriv&)
/ method implemented by the component."
      end

      operation 224688 "addDForce"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "dfId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Compute the force derivative given a small displacement from the
/ position and velocity used in the previous call to addForce().
/
/ The derivative should be directly derived from the computations
/ done by addForce. Any forces neglected in addDForce will be integrated
/ explicitly (i.e. using its value at the beginning of the timestep).
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ df += kFactor K dx + bFactor B dx $
/
/ This method retrieves the force and dx vector from the two MechanicalState
/ and call the internal addDForce(VecDeriv1&,VecDeriv2&,const VecDeriv1&,const VecDeriv2&,double,double)
/ method implemented by the component."
      end

      operation 224816 "getPotentialEnergy"
	const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Get the potential energy associated to this ForceField.
/
/ Used to extimate the total energy of the system by some
/ post-stabilization techniques.
/
/ This method retrieves the x vector from the MechanicalState and call
/ the internal getPotentialEnergy(const VecCoord&,const VecCoord&) method implemented by
/ the component."
      end

      operation 224944 "addForce"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 7
	  param inout name "f1" type class_ref 165168 // DataVecDeriv1
	  param inout name "f2" type class_ref 165424 // DataVecDeriv2
	  param in name "x1" type class_ref 165040 // DataVecCoord1
	  param in name "x2" type class_ref 165296 // DataVecCoord2
	  param in name "v1" type class_ref 165168 // DataVecDeriv1
	  param in name "v2" type class_ref 165424 // DataVecDeriv2
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}, const ${t3} & ${p3}${v3}, const ${t4} & ${p4}${v4}, const ${t5} & ${p5}${v5}, const ${t6} * ${p6}${v6}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Given the current position and velocity states, update the current force
/ vector by computing and adding the forces associated with this
/ ForceField.
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ f += B v + K x $
/
/ This method must be implemented by the component, and is usually called
/ by the generic ForceField::addForce() method."
      end

      operation 225072 "addDForce"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 5
	  param inout name "df1" type class_ref 165168 // DataVecDeriv1
	  param inout name "df2" type class_ref 165424 // DataVecDeriv2
	  param in name "dx1" type class_ref 165168 // DataVecDeriv1
	  param in name "dx2" type class_ref 165424 // DataVecDeriv2
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}, const ${t3} & ${p3}${v3}, const ${t4} * ${p4}${v4}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @deprecated
virtual void addForce(VecDeriv1& f1, VecDeriv2& f2, const VecCoord1& x1, const VecCoord2& x2, const VecDeriv1& v1, const VecDeriv2& v2);
/ Compute the force derivative given a small displacement from the
/ position and velocity used in the previous call to addForce().
/
/ The derivative should be directly derived from the computations
/ done by addForce. Any forces neglected in addDForce will be integrated
/ explicitly (i.e. using its value at the beginning of the timestep).
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ df += K dx $
/
/ This method must be implemented by the component, and is usually called
/ by the generic MixedInteractionForceField::addDForce() method.
/
/ @deprecated to more efficiently accumulate contributions from all terms
/   of the system equation, a new addDForce method allowing to pass two
/   coefficients for the stiffness and damping terms should now be used."
      end

      operation 225200 "getPotentialEnergy"
	abstract const cpp_virtual public explicit_return_type "double"
	nparams 3
	  param in name "x1" type class_ref 165040 // DataVecCoord1
	  param in name "x2" type class_ref 165296 // DataVecCoord2
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @deprecated
virtual void addDForce(VecDeriv1& df1, VecDeriv2& df2, const VecDeriv1& dx1, const VecDeriv2& dx2, double kFactor, double /*bFactor*/);
virtual void addDForce(VecDeriv1& df1, VecDeriv2& df2, const VecDeriv1& dx1, const VecDeriv2& dx2);
/ Compute the force derivative given a small displacement from the
/ position and velocity used in the previous call to addForce().
/
/ The derivative should be directly derived from the computations
/ done by addForce. Any forces neglected in addDForce will be integrated
/ explicitly (i.e. using its value at the beginning of the timestep).
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ df += kFactor K dx + bFactor B dx $
/
/ This method must be implemented by the component, and is usually called
/ by the generic MixedInteractionForceField::addDForce() method.
/
/ To support old components that implement the deprecated addForce method
/ without scalar coefficients, it defaults to using a temporaty vector to
/ compute $ K dx $ and then manually scaling all values by kFactor.
/ @deprecated
/ Get the potential energy associated to this ForceField.
/
/ Used to extimate the total energy of the system by some
/ post-stabilization techniques.
/
/ This method must be implemented by the component, and is usually called
/ by the generic ForceField::getPotentialEnergy() method."
      end

      operation 225328 "canCreate"
	stereotype "template"
	class_operation cpp_inline public explicit_return_type "bool"
	nparams 3
	  param inout name "obj" explicit_type "T"
	  param inout name "context" type class_ref 141104 // BaseContext
	  param inout name "arg" type class_ref 141232 // BaseObjectDescription
	cpp_decl "    ${comment}template<class T>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * & ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        if (arg->getAttribute(\"object1\") || arg->getAttribute(\"object2\"))
        {
            if (dynamic_cast<MechanicalState<DataTypes1>*>(arg->findObject(arg->getAttribute(\"object1\",\"..\"))) == NULL)
                return false;
            if (dynamic_cast<MechanicalState<DataTypes2>*>(arg->findObject(arg->getAttribute(\"object2\",\"..\"))) == NULL)
                return false;
        }
        return BaseInteractionForceField::canCreate(obj, context, arg);
    };
"
	
	
	
	
	comment "/ @deprecated
virtual double getPotentialEnergy(const VecCoord1& x1, const VecCoord2& x2) const;
/ @}
/ Pre-construction check method called by ObjectFactory.
/ Check that DataTypes matches the MechanicalState."
      end

      operation 225456 "create"
	stereotype "template"
	class_operation cpp_inline public explicit_return_type "void"
	nparams 3
	  param inout name "obj" explicit_type "T"
	  param inout name "context" type class_ref 141104 // BaseContext
	  param inout name "arg" type class_ref 141232 // BaseObjectDescription
	cpp_decl "    ${comment}template<class T>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * & ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        core::behavior::BaseInteractionForceField::create(obj, context, arg);
        if (arg && (arg->getAttribute(\"object1\") || arg->getAttribute(\"object2\")))
        {
            obj->mstate1 = dynamic_cast<MechanicalState<DataTypes1>*>(arg->findObject(arg->getAttribute(\"object1\",\"..\")));
            obj->mstate2 = dynamic_cast<MechanicalState<DataTypes2>*>(arg->findObject(arg->getAttribute(\"object2\",\"..\")));
        }
    };
"
	
	
	
	
	comment "/ Construction method called by ObjectFactory."
      end

      operation 225584 "getTemplateName"
	const cpp_virtual cpp_inline public explicit_return_type "std::string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        return templateName(this);
    };
"
	
	
	
	
      end

      operation 225712 "templateName"
	class_operation cpp_inline public explicit_return_type "std::string"
	nparams 1
	  param in name "" explicit_type "MixedInteractionForceField<DataTypes1,DataTypes2>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return DataTypes1::Name()+std::string(\",\")+DataTypes2::Name();
    };
"
	
	
	
	
      end

      attribute 144048 "mstate1"
	protected explicit_type "DataTypes1"
	stereotype "MechanicalState"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 144176 "mstate2"
	protected explicit_type "DataTypes2"
	stereotype "MechanicalState"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      classrelation 149680 // mask1 (<unidirectional association>)
	relation 149680 --->
	  a role_name "mask1" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 149680 // mask1 (<unidirectional association>)
	  b parent class_ref 164912 // ParticleMask
      end

      classrelation 149808 // mask2 (<unidirectional association>)
	relation 149808 --->
	  a role_name "mask2" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 149808 // mask2 (<unidirectional association>)
	  b parent class_ref 164912 // ParticleMask
      end
    end

    class 165552 "MechanicalMatrix"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "/ Helper class allowing to construct mechanical expressions
/"
      class 165680 "anonymous4"
	visibility package stereotype "enum"
	cpp_decl "${comment}enum  {
${items}
};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	attribute 144304 "MFACT"
	  public type class_ref 165680 // anonymous4
	  init_value " 0"
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	attribute 144432 "BFACT"
	  public type class_ref 165680 // anonymous4
	  init_value " 1"
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	attribute 144560 "KFACT"
	  public type class_ref 165680 // anonymous4
	  init_value " 2 "
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end
      end

      attribute 144688 "factors"
	protected explicit_type "3,double"
	stereotype "defaulttype::Vec"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      operation 225840 "MechanicalMatrix"
	cpp_inline public explicit_return_type ""
	nparams 3
	  param in name "m" explicit_type "double"
	  param in name "b" explicit_type "double"
	  param in name "k" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw} : factors(m,b,k) {};
"
	
	
	
	
      end

      operation 225968 "MechanicalMatrix"
	cpp_inline public explicit_return_type ""
	nparams 1
	  param in name "f" explicit_type "defaulttype::Vec<3,double>"
	cpp_decl "    ${comment}${inline}explicit ${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw} : factors(f) {};
"
	
	
	
	
      end

      classrelation 149936 // M (<directional composition>)
	relation 149936 *-->
	  a role_name "M" init_value "(1,0,0)" class_relation const_relation public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 149936 // M (<directional composition>)
	  b parent class_ref 165552 // MechanicalMatrix
      end

      classrelation 150064 // B (<directional composition>)
	relation 150064 *-->
	  a role_name "B" init_value "(0,1,0)" class_relation const_relation public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 150064 // B (<directional composition>)
	  b parent class_ref 165552 // MechanicalMatrix
      end

      classrelation 150192 // K (<directional composition>)
	relation 150192 *-->
	  a role_name "K" init_value "(0,0,1)" class_relation const_relation public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 150192 // K (<directional composition>)
	  b parent class_ref 165552 // MechanicalMatrix
      end

      operation 226096 "getMFact"
	const cpp_inline public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return factors[MFACT]; };
"
	
	
	
	
      end

      operation 226224 "getBFact"
	const cpp_inline public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return factors[BFACT]; };
"
	
	
	
	
      end

      operation 226352 "getKFact"
	const cpp_inline public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return factors[KFACT]; };
"
	
	
	
	
      end

      operation 226480 "operator +"
	const cpp_inline public return_type class_ref 165552 // MechanicalMatrix
	nparams 1
	  param in name "m2" type class_ref 165552 // MechanicalMatrix
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return MechanicalMatrix(factors + m2.factors); };
"
	
	
	
	
      end

      operation 226608 "operator -"
	const cpp_inline public return_type class_ref 165552 // MechanicalMatrix
	nparams 1
	  param in name "m2" type class_ref 165552 // MechanicalMatrix
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return MechanicalMatrix(factors - m2.factors); };
"
	
	
	
	
      end

      operation 226736 "operator -"
	const cpp_inline public return_type class_ref 165552 // MechanicalMatrix
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return MechanicalMatrix(- factors); };
"
	
	
	
	
      end

      operation 226864 "operator *"
	const cpp_inline public return_type class_ref 165552 // MechanicalMatrix
	nparams 1
	  param in name "f" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return MechanicalMatrix(factors * f); };
"
	
	
	
	
      end

      operation 226992 "operator /"
	const cpp_inline public return_type class_ref 165552 // MechanicalMatrix
	nparams 1
	  param in name "f" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return MechanicalMatrix(factors / f); };
"
	
	
	
	
	comment "friend MechanicalMatrix operator * (double f, const MechanicalMatrix& m1) { return MechanicalMatrix(m1.factors * f); }"
      end

      operation 227120 "operator <<"
	friend cpp_inline public explicit_return_type "std::ostream"
	nparams 2
	  param inout name "out" explicit_type "std::ostream"
	  param in name "m" type class_ref 165552 // MechanicalMatrix
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
        out << '(';
        bool first = true;
        for (unsigned int i=0;i<m.factors.size();++i)
        {
            double f = m.factors[i];
            if (f!=0.0)
            {
                if (!first) out << ' ';
                if (f == -1.0) out << '-';
                else if (f < 0) out << f << ' ';
                else
                {
                    if (!first) out << '+';
                    if (f != 1.0) out << f << ' ';
                }
                out << (\"MBK\")[i];
                first = false;
            }
        }
        out << ')';
        return out;
    };
"
	
	
	
	
      end
    end

    class 165808 "MultiMatrix"
      visibility package 
      nformals 1
      formal name "Parent" type "class" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "/ Helper class providing a high-level view of underlying linear system matrices.
/
/ It is used to convert math-like operations to call to computation methods."
      class 165936 "VecId"
	visibility package stereotype "typedef" base_type class_ref 147120 // VecId
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 150320 // <dependency>
	  relation 150320 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 150320 // <dependency>
	    b parent class_ref 147120 // VecId
	end
      end

      attribute 144816 "parent"
	protected explicit_type "Parent"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      operation 227248 "MultiMatrix"
	protected explicit_return_type ""
	nparams 1
	  param in name "" type class_ref 165808 // MultiMatrix
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}const ${t0} & ${p0}${)}${throw}{
  ${body}}
"
	
	
	
	
	comment "/ Copy-constructor is forbidden"
      end

      operation 227376 "MultiMatrix"
	cpp_inline public explicit_return_type ""
	nparams 1
	  param inout name "parent" explicit_type "Parent"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}${)}${volatile}${throw} : parent(parent)
    {
    };
"
	
	
	
	
      end

      operation 227504 "~MultiMatrix"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {
    };
"
	
	
	
	
      end

      operation 227632 "clear"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        parent->m_resetSystem();
    };
"
	
	
	
	
	comment "/ m = 0"
      end

      operation 227760 "reset"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        parent->m_resetSystem();
    };
"
	
	
	
	
	comment "/ m = 0"
      end

      operation 227888 "operator ="
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "m" type class_ref 165552 // MechanicalMatrix
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        parent->m_setSystemMBKMatrix(m.getMFact(), m.getBFact(), m.getKFact());
    };
"
	
	
	
	
	comment "/ m = m*M+b*B+k*K"
      end

      operation 228016 "solve"
	cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "solution" type class_ref 128816 // MultiVecDerivId
	  param in name "rh" type class_ref 128816 // MultiVecDerivId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
        parent->m_setSystemRHVector(rh);
        parent->m_setSystemLHVector(solution);
        parent->m_solveSystem();
    };
"
	
	
	
	
      end

      operation 228144 "operator <<"
	friend cpp_inline public explicit_return_type "std::ostream"
	nparams 2
	  param inout name "out" explicit_type "std::ostream"
	  param in name "m" type class_ref 165808 // MultiMatrix
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
        m.parent->m_print(out);
        return out;
    };
"
	
	
	
	
      end
    end

    class 166320 "TMultiVec"
      visibility package 
      nformals 1
      formal name "vtype" type "VecType" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "/ Helper class providing a high-level view of underlying state vectors.
/
/ It is used to convert math-like operations to call to computation methods."
      class 166448 "MyMultiVecId"
	visibility package stereotype "typedef" explicit_base_type "TMultiVecId<vtype, V_WRITE>"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 166576 "ConstMyMultiVecId"
	visibility package stereotype "typedef" explicit_base_type "TMultiVecId<vtype, V_READ>"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 166704 "AllMultiVecId"
	visibility package stereotype "typedef" explicit_base_type "TMultiVecId<V_ALL, V_WRITE>"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 166832 "ConstAllMultiVecId"
	visibility package stereotype "typedef" explicit_base_type "TMultiVecId<V_ALL, V_READ>"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      classrelation 150448 // vop (<unidirectional association>)
	relation 150448 --->
	  a role_name "vop" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 150448 // vop (<unidirectional association>)
	  b parent class_ref 152624 // BaseVectorOperations
      end

      classrelation 150576 // v (<directional composition>)
	relation 150576 *-->
	  a role_name "v" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 150576 // v (<directional composition>)
	  b parent class_ref 166448 // MyMultiVecId
      end

      attribute 145328 "dynamic"
	protected explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      operation 230320 "TMultiVec"
	cpp_inline private explicit_return_type ""
	nparams 1
	  param in name "" explicit_type "TMultiVec<vtype>"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw} {};
"
	
	
	
	
	comment "/ Copy-constructor is forbidden"
      end

      operation 230448 "TMultiVec"
	cpp_inline public explicit_return_type ""
	nparams 2
	  param inout name "vop" type class_ref 152624 // BaseVectorOperations
	  param in name "v" type class_ref 166448 // MyMultiVecId
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw} : vop(vop), v(v), dynamic(false)
    {};
"
	
	
	
	
	comment "/ Refers to a state vector with the given ID (VecId::position(), VecId::velocity(), etc)."
      end

      operation 230576 "TMultiVec"
	cpp_inline public explicit_return_type ""
	nparams 1
	  param inout name "vop" type class_ref 152624 // BaseVectorOperations
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}${)}${volatile}${throw} : vop(vop), v(MyMultiVecId::null()), dynamic(true)
    {
        BOOST_STATIC_ASSERT(vtype == V_COORD || vtype == V_DERIV);
        vop->v_alloc( v );
    };
"
	
	
	
	
	comment "/ Allocate a new temporary vector with the given type (sofa::core::V_COORD or sofa::core::V_DERIV)."
      end

      operation 230704 "~TMultiVec"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {
        if (dynamic) vop->v_free(v);
    };
"
	
	
	
	
      end

      operation 230832 "operator MyMultiVecId"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${name}${(}${)}${const}${volatile}${throw}${abstract} {  return v;  };
"
	
	
	
	
	comment "/ Automatic conversion to the underlying VecId"
      end

      operation 230960 "operator ConstMyMultiVecId"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${name}${(}${)}${const}${volatile}${throw}${abstract} {  return v;  };
"
	
	
	
	
      end

      operation 231088 "operator AllMultiVecId"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${name}${(}${)}${const}${volatile}${throw}${abstract} {  return v;  };
"
	
	
	
	
      end

      operation 231216 "operator ConstAllMultiVecId"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${name}${(}${)}${const}${volatile}${throw}${abstract} {  return v;  };
"
	
	
	
	
      end

      operation 231344 "id"
	cpp_inline public return_type class_ref 166448 // MyMultiVecId
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} & ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        return v;
    };
"
	
	
	
	
      end

      operation 231472 "ops"
	cpp_inline public return_type class_ref 152624 // BaseVectorOperations
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return vop; };
"
	
	
	
	
      end

      operation 231600 "setOps"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param inout name "op" type class_ref 152624 // BaseVectorOperations
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { vop = op; };
"
	
	
	
	
      end

      operation 231728 "clear"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        vop->v_clear(v);
    };
"
	
	
	
	
	comment "/ v = 0"
      end

      operation 231856 "eq"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "a" type class_ref 166448 // MyMultiVecId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        vop->v_eq(v, a);
    };
"
	
	
	
	
	comment "/ v = a"
      end

      operation 231984 "peq"
	cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "a" type class_ref 166704 // AllMultiVecId
	  param in name "f" explicit_type "double"
	    defaultvalue "1.0"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
        vop->v_peq(v, a, f);
    };
"
	
	
	
	
	comment "/ v += a*f"
      end

      operation 232112 "teq"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "f" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        vop->v_teq(v, f);
    };
"
	
	
	
	
	comment "/ v *= f"
      end

      operation 232240 "eq"
	cpp_inline public explicit_return_type "void"
	nparams 3
	  param in name "a" type class_ref 166704 // AllMultiVecId
	  param in name "b" type class_ref 166704 // AllMultiVecId
	  param in name "f" explicit_type "double"
	    defaultvalue "1.0"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        vop->v_op(v, a, b, f);
    };
"
	
	
	
	
	comment "/ v = a+b*f"
      end

      operation 232368 "dot"
	cpp_inline public explicit_return_type "double"
	nparams 1
	  param in name "a" type class_ref 166448 // MyMultiVecId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        vop->v_dot(v, a);
        return vop->finish();
    };
"
	
	
	
	
	comment "/ \\return v.a"
      end

      operation 232496 "threshold"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "threshold" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
      vop->v_threshold(v, threshold);
    };
"
	
	
	
	
	comment "/ nullify values below given threshold "
      end

      operation 232624 "norm"
	cpp_inline public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        vop->v_dot(v, v);
        return sqrt( vop->finish() );
    };
"
	
	
	
	
	comment "/ \\return sqrt(v.v)"
      end

      operation 232752 "operator ="
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "a" type class_ref 166448 // MyMultiVecId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        eq(a);
    };
"
	
	
	
	
	comment "/ v = a"
      end

      operation 232880 "operator ="
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "a" explicit_type "TMultiVec<vtype>"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        eq(a.v);
    };
"
	
	
	
	
	comment "/ v = a"
      end

      operation 233008 "operator +="
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "a" type class_ref 166448 // MyMultiVecId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        peq(a);
    };
"
	
	
	
	
	comment "/ v += a"
      end

      operation 233136 "operator -="
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "a" type class_ref 166448 // MyMultiVecId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        peq(a,-1);
    };
"
	
	
	
	
	comment "/ v -= a"
      end

      operation 233264 "operator *="
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "f" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        teq(f);
    };
"
	
	
	
	
	comment "/ v *= f"
      end

      operation 233392 "operator /="
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "f" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        teq(1.0/f);
    };
"
	
	
	
	
	comment "/ v /= f"
      end

      operation 233520 "operator *"
	cpp_inline public explicit_return_type "double"
	nparams 1
	  param in name "a" type class_ref 166448 // MyMultiVecId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return dot(a);
    };
"
	
	
	
	
	comment "/ return the scalar product dot(v,a)"
      end

      operation 233648 "operator <<"
	friend cpp_inline public explicit_return_type "std::ostream"
	nparams 2
	  param inout name "out" explicit_type "std::ostream"
	  param in name "mv" explicit_type "TMultiVec<vtype>"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
        mv.vop->print(mv.v,out);
        return out;
    };
"
	
	
	
	
      end
    end

    class 166960 "MultiVecCoord"
      visibility package stereotype "typedef" explicit_base_type "TMultiVec<V_COORD>"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
    end

    class 167088 "MultiVecDeriv"
      visibility package stereotype "typedef" explicit_base_type "TMultiVec<V_DERIV>"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
    end

    class 167216 "MultiVecMatrixDeriv"
      visibility package stereotype "typedef" explicit_base_type "TMultiVec<V_MATDERIV>"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
    end

    class 167344 "OdeSolver"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component responsible for timestep integration, i.e. advancing the state from time t to t+dt.
 *
 *  This class currently control both the integration scheme (explicit,
 *  implicit, static, etc), and the linear system resolution algorithm
 *  (conjugate gradient, matrix direct inversion, etc). Those two aspect will
 *  propably be separated in a future version.
 *
 *  While all computations required to do the integration step are handled by
 *  this object, they should not be implemented directly in it, but instead
 *  the solver propagates orders (or Visitor) to the other components in the
 *  scenegraph that will locally execute them. This allow for greater
 *  flexibility (the solver can just ask for the forces to be computed without
 *  knowing what type of forces are present), as well as performances
 *  (some computations can be executed in parallel).
 *"
      classrelation 150704 // <generalisation>
	relation 150704 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 150704 // <generalisation>
	  b parent class_ref 149424 // typedef7
      end

      classrelation 150832 // <generalisation>
	relation 150832 ---|>
	  a private
	    cpp default "${type}"
	    classrelation_ref 150832 // <generalisation>
	  b parent class_ref 128304 // BaseObject
      end

      operation 233776 "OdeSolver"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 233904 "~OdeSolver"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 234032 "solve"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 4
	  param in name "" explicit_type "double"
	  param in name "" type class_ref 128432 // MultiVecCoordId
	  param in name "" type class_ref 128816 // MultiVecDerivId
	  param in name "" type class_ref 132912 // ExecParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, const ${t3} * ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Main computation method.
/
/ Specify and execute all computation for timestep integration, i.e.
/ advancing the state from time t to t+dt, putting the resulting position and velocity in the provided vectors."
      end

      operation 234160 "solve"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "dt" explicit_type "double"
	  param in name "params" type class_ref 132912 // ExecParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} { solve(dt, VecCoordId::position(), VecDerivId::velocity(), params); };
"
	
	
	
	
	comment " { serr << \"ERROR: \" << getClassName() << \" don't implement solve on custom x and v\" << sendl; }
/ Main computation method.
/
/ Specify and execute all computation for timestep integration, i.e.
/ advancing the state from time t to t+dt."
      end

      operation 234288 "getIntegrationFactor"
	abstract const cpp_virtual public explicit_return_type "double"
	nparams 2
	  param in name "inputDerivative" explicit_type "int"
	  param in name "outputDerivative" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Given an input derivative order (0 for position, 1 for velocity, 2 for acceleration),
/ how much will it affect the output derivative of the given order.
/
/ This method is used to compute the constraint corrections and adapt the resolution if using baumgart type scheme
/ For example, a backward-Euler dynamic implicit integrator would use:
/ Input:      x_t  v_t  a_{t+dt}
/ x_{t+dt}     1    dt  dt^2
/ v_{t+dt}     0    1   dt
/
/ If the linear system is expressed on s = a_{t+dt} dt, then the final factors are:
/ Input:      x_t   v_t    a_t  s
/ x_{t+dt}     1    dt     0    dt
/ v_{t+dt}     0    1      0    1
/ a_{t+dt}     0    0      0    1/dt
/ The last column is returned by the getSolutionIntegrationFactor method."
      end

      operation 234416 "getSolutionIntegrationFactor"
	abstract const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "outputDerivative" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Given a solution of the linear system,
/ how much will it affect the output derivative of the given order.
/"
      end

      operation 234544 "getVelocityIntegrationFactor"
	const cpp_virtual cpp_inline public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
	  return getSolutionIntegrationFactor(1);
	};
"
	
	
	
	
	comment "/ Given the solution dx of the linear system inversion, how much will it affect the velocity
/
/ This method is used to compute the compliance for contact corrections"
      end

      operation 234672 "getPositionIntegrationFactor"
	const cpp_virtual cpp_inline public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
	  return getSolutionIntegrationFactor(0);
	};
"
	
	
	
	
	comment "/ Given the solution dx of the linear system inversion, how much will it affect the position
/
/ This method is used to compute the compliance for contact corrections"
      end
    end

    class 167472 "PairInteractionConstraint"
      abstract visibility package 
      nformals 1
      formal name "TDataTypes" type "class" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component computing constraints between a pair of simulated body.
 *
 *  This class define the abstract API common to interaction constraints
 *  between a pair of bodies using a given type of DOFs."
      classrelation 150960 // <generalisation>
	relation 150960 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 150960 // <generalisation>
	  b parent class_ref 149936 // BaseInteractionConstraint
      end

      class 167600 "DataTypes"
	visibility package stereotype "typedef" explicit_base_type "TDataTypes"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 167728 "VecCoord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 167856 "VecDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 167984 "MatrixDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::MatrixDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 168112 "Coord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 168240 "Deriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 168368 "Real"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Real"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 168496 "DataVecCoord"
	visibility package stereotype "typedef" base_type class_ref 167728 // VecCoord
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 151088 // <dependency>
	  relation 151088 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 151088 // <dependency>
	    b parent class_ref 167728 // VecCoord
	end
      end

      class 168624 "DataVecDeriv"
	visibility package stereotype "typedef" base_type class_ref 167856 // VecDeriv
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 151216 // <dependency>
	  relation 151216 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 151216 // <dependency>
	    b parent class_ref 167856 // VecDeriv
	end
      end

      class 168752 "DataMatrixDeriv"
	visibility package stereotype "typedef" base_type class_ref 167984 // MatrixDeriv
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 151344 // <dependency>
	  relation 151344 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 151344 // <dependency>
	    b parent class_ref 167984 // MatrixDeriv
	end
      end

      operation 234800 "PairInteractionConstraint"
	public explicit_return_type ""
	nparams 2
	  param inout name "mm1" explicit_type "MechanicalState<DataTypes>"
	    defaultvalue "NULL"
	  param inout name "mm2" explicit_type "MechanicalState<DataTypes>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, ${t1} * ${p1}${v1}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}, ${t1} * ${p1}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 234928 "~PairInteractionConstraint"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      attribute 145456 "endTime"
	public explicit_type "double"
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "/< Time when the constraint becomes inactive (-1 for infinitely active)"
      end

      operation 235056 "isActive"
	const cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 235184 "init"
	cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/< if false, the constraint does nothing"
      end

      operation 235312 "getMState1"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate1; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 235440 "getMechModel1"
	cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate1; };
"
	
	
	
	
      end

      operation 235568 "getMState2"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate2; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 235696 "getMechModel2"
	cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate2; };
"
	
	
	
	
      end

      operation 235824 "getConstraintViolation"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param inout name "v" explicit_type "defaulttype::BaseVector"
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Construct the Constraint violations vector of each constraint
/
/ \\param v is the result vector that contains the whole constraints violations
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)"
      end

      operation 235952 "getConstraintViolation"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 6
	  param inout name "v" explicit_type "defaulttype::BaseVector"
	  param in name "x1" type class_ref 168496 // DataVecCoord
	  param in name "x2" type class_ref 168496 // DataVecCoord
	  param in name "v1" type class_ref 168624 // DataVecDeriv
	  param in name "v2" type class_ref 168624 // DataVecDeriv
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}, const ${t3} & ${p3}${v3}, const ${t4} & ${p4}${v4}, const ${t5} * ${p5}${v5}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Construct the Constraint violations vector of each constraint
/
/ \\param v is the result vector that contains the whole constraints violations
/ \\param x1 and x2 are the position vectors used to compute contraint position violation
/ \\param v1 and v2 are the velocity vectors used to compute contraint velocity violation
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)
/
/ This is the method that should be implemented by the component"
      end

      operation 236080 "buildConstraintMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "cId" type class_ref 129072 // MultiMatrixDerivId
	  param inout name "cIndex" explicit_type "uint"
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} & ${p1}, const ${t2} * ${p2}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Construct the Jacobian Matrix
/
/ \\param cId is the result constraint sparse matrix Id
/ \\param cIndex is the index of the next constraint equation: when building the constraint matrix, you have to use this index, and then update it
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)"
      end

      operation 236208 "buildConstraintMatrix"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 6
	  param inout name "c1" type class_ref 168752 // DataMatrixDeriv
	  param inout name "c2" type class_ref 168752 // DataMatrixDeriv
	  param inout name "cIndex" explicit_type "uint"
	  param in name "x1" type class_ref 168496 // DataVecCoord
	  param in name "x2" type class_ref 168496 // DataVecCoord
	  param in name "cParams" type class_ref 129328 // ConstraintParams
	    defaultvalue "ConstraintParams::defaultInstance()"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}, const ${t3} & ${p3}${v3}, const ${t4} & ${p4}${v4}, const ${t5} * ${p5}${v5}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Construct the Jacobian Matrix
/
/ \\param c1 and c2 are the results constraint sparse matrix
/ \\param cIndex is the index of the next constraint equation: when building the constraint matrix, you have to use this index, and then update it
/ \\param x1 and x2 are the position vectors used for contraint equation computation
/ \\param cParams defines the state vectors to use for positions and velocities. Also defines the order of the constraint (POS, VEL, ACC)
/
/ This is the method that should be implemented by the component"
      end

      operation 236336 "canCreate"
	stereotype "template"
	class_operation cpp_inline public explicit_return_type "bool"
	nparams 3
	  param inout name "obj" explicit_type "T"
	  param inout name "context" type class_ref 141104 // BaseContext
	  param inout name "arg" type class_ref 141232 // BaseObjectDescription
	cpp_decl "    ${comment}template<class T>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * & ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        if (arg->getAttribute(\"object1\") || arg->getAttribute(\"object2\"))
        {
            if (dynamic_cast<MechanicalState<DataTypes>*>(arg->findObject(arg->getAttribute(\"object1\",\"..\"))) == NULL)
                return false;
            if (dynamic_cast<MechanicalState<DataTypes>*>(arg->findObject(arg->getAttribute(\"object2\",\"..\"))) == NULL)
                return false;
        }
        else
        {
            if (dynamic_cast<MechanicalState<DataTypes>*>(context->getMechanicalState()) == NULL)
                return false;
        }
        return BaseInteractionConstraint::canCreate(obj, context, arg);
    };
"
	
	
	
	
	comment "/ Pre-construction check method called by ObjectFactory.
/ Check that DataTypes matches the MechanicalState."
      end

      operation 236464 "create"
	stereotype "template"
	class_operation cpp_inline public explicit_return_type "void"
	nparams 3
	  param inout name "obj" explicit_type "T"
	  param inout name "context" type class_ref 141104 // BaseContext
	  param inout name "arg" type class_ref 141232 // BaseObjectDescription
	cpp_decl "    ${comment}template<class T>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * & ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        core::behavior::BaseInteractionConstraint::create(obj, context, arg);
        if (arg && (arg->getAttribute(\"object1\") || arg->getAttribute(\"object2\")))
        {
            obj->mstate1 = dynamic_cast<MechanicalState<DataTypes>*>(arg->findObject(arg->getAttribute(\"object1\",\"..\")));
            obj->mstate2 = dynamic_cast<MechanicalState<DataTypes>*>(arg->findObject(arg->getAttribute(\"object2\",\"..\")));
        }
        else if (context)
        {
            obj->mstate1 =
            obj->mstate2 =
                dynamic_cast<MechanicalState<DataTypes>*>(context->getMechanicalState());
        }
    };
"
	
	
	
	
	comment "/ Construction method called by ObjectFactory."
      end

      operation 236592 "getTemplateName"
	const cpp_virtual cpp_inline public explicit_return_type "std::string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        return templateName(this);
    };
"
	
	
	
	
      end

      operation 236720 "templateName"
	class_operation cpp_inline public explicit_return_type "std::string"
	nparams 1
	  param in name "" explicit_type "PairInteractionConstraint<DataTypes>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return DataTypes::Name();
    };
"
	
	
	
	
      end

      attribute 145584 "object1"
	protected explicit_type " std::string "
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 145712 "object2"
	protected explicit_type " std::string "
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 145840 "mstate1"
	protected explicit_type "DataTypes"
	stereotype "MechanicalState"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 145968 "mstate2"
	protected explicit_type "DataTypes"
	stereotype "MechanicalState"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 168880 "PairInteractionForceField"
      abstract visibility package 
      nformals 1
      formal name "DataTypes" type "class" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component computing forces between a pair of simulated body.
 *
 *  This class define the abstract API common to interaction force fields
 *  between a pair of bodies using a given type of DOFs."
      classrelation 151472 // <generalisation>
	relation 151472 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 151472 // <generalisation>
	  b parent class_ref 150192 // BaseInteractionForceField
      end

      class 169008 "DataTypes"
	visibility package stereotype "typedef" explicit_base_type "TDataTypes"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 169136 "VecCoord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 169264 "VecDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 169392 "Coord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 169520 "Deriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 169648 "ParticleMask"
	visibility package stereotype "typedef" explicit_base_type "helper::ParticleMask"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 169776 "DataVecCoord"
	visibility package stereotype "typedef" base_type class_ref 169136 // VecCoord
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 151600 // <dependency>
	  relation 151600 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 151600 // <dependency>
	    b parent class_ref 169136 // VecCoord
	end
      end

      class 169904 "DataVecDeriv"
	visibility package stereotype "typedef" base_type class_ref 169264 // VecDeriv
	cpp_decl "${comment}typedef core::objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 151728 // <dependency>
	  relation 151728 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 151728 // <dependency>
	    b parent class_ref 169264 // VecDeriv
	end
      end

      operation 236848 "PairInteractionForceField"
	public explicit_return_type ""
	nparams 2
	  param inout name "mm1" explicit_type "MechanicalState<DataTypes>"
	    defaultvalue "NULL"
	  param inout name "mm2" explicit_type "MechanicalState<DataTypes>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, ${t1} * ${p1}${v1}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}, ${t1} * ${p1}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 236976 "~PairInteractionForceField"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 237104 "init"
	cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 237232 "getMState1"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate1; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 237360 "getMechModel1"
	cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate1; };
"
	
	
	
	
      end

      operation 237488 "getMState2"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate2; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 237616 "getMechModel2"
	cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate2; };
"
	
	
	
	
      end

      operation 237744 "setPathObject1"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "path" explicit_type "std::string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { _object1.setValue(path); };
"
	
	
	
	
	comment "/ Set the Object1 path"
      end

      operation 237872 "setPathObject2"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "path" explicit_type "std::string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { _object2.setValue(path); };
"
	
	
	
	
	comment "/ Set the Object2 path"
      end

      operation 238000 "getPathObject1"
	const cpp_inline public explicit_return_type "std::string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return _object1.getValue(); };
"
	
	
	
	
	comment "/ Retrieve the Object1 path"
      end

      operation 238128 "getPathObject2"
	const cpp_inline public explicit_return_type "std::string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return _object2.getValue(); };
"
	
	
	
	
	comment "/ Retrieve the Object2 path"
      end

      operation 238256 "getMState"
	public return_type class_ref 150064 // BaseMechanicalState
	nparams 2
	  param inout name "context" type class_ref 141104 // BaseContext
	  param in name "path" explicit_type "std::string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} * ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState given the path"
      end

      operation 238384 "addForce"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "fId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @name Vector operations
/ @{
/ Given the current position and velocity states, update the current force
/ vector by computing and adding the forces associated with this
/ ForceField.
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ f += B v + K x $
/
/ This method retrieves the force, x and v vector from the two MechanicalState
/ and call the internal addForce(VecDeriv&,VecDeriv&,const VecCoord&,const VecCoord&,const VecDeriv&,const VecDeriv&)
/ method implemented by the component."
      end

      operation 238512 "addDForce"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "dfId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Compute the force derivative given a small displacement from the
/ position and velocity used in the previous call to addForce().
/
/ The derivative should be directly derived from the computations
/ done by addForce. Any forces neglected in addDForce will be integrated
/ explicitly (i.e. using its value at the beginning of the timestep).
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ df += kFactor K dx + bFactor B dx $
/
/ This method retrieves the force and dx vector from the two MechanicalState
/ and call the internal addDForce(VecDeriv&,VecDeriv&,const VecDeriv&,const VecDeriv&,double,double)
/ method implemented by the component."
      end

      operation 238640 "getPotentialEnergy"
	const cpp_virtual public explicit_return_type "double"
	nparams 1
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Get the potential energy associated to this ForceField.
/
/ Used to extimate the total energy of the system by some
/ post-stabilization techniques.
/
/ This method retrieves the x vector from the MechanicalState and call
/ the internal getPotentialEnergy(const VecCoord&,const VecCoord&) method implemented by
/ the component."
      end

      operation 238768 "addForce"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 7
	  param inout name "f1" type class_ref 169904 // DataVecDeriv
	  param inout name "f2" type class_ref 169904 // DataVecDeriv
	  param in name "x1" type class_ref 169776 // DataVecCoord
	  param in name "x2" type class_ref 169776 // DataVecCoord
	  param in name "v1" type class_ref 169904 // DataVecDeriv
	  param in name "v2" type class_ref 169904 // DataVecDeriv
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}, const ${t3} & ${p3}${v3}, const ${t4} & ${p4}${v4}, const ${t5} & ${p5}${v5}, const ${t6} * ${p6}${v6}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Given the current position and velocity states, update the current force
/ vector by computing and adding the forces associated with this
/ ForceField.
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ f += B v + K x $
/
/ This method must be implemented by the component, and is usually called
/ by the generic ForceField::addForce() method."
      end

      operation 238896 "addDForce"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 5
	  param inout name "df1" type class_ref 169904 // DataVecDeriv
	  param inout name "df2" type class_ref 169904 // DataVecDeriv
	  param in name "dx1" type class_ref 169904 // DataVecDeriv
	  param in name "dx2" type class_ref 169904 // DataVecDeriv
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}, const ${t3} & ${p3}${v3}, const ${t4} * ${p4}${v4}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @deprecated
virtual void addForce(VecDeriv& f1, VecDeriv& f2, const VecCoord& x1, const VecCoord& x2, const VecDeriv& v1, const VecDeriv& v2);
/ Compute the force derivative given a small displacement from the
/ position and velocity used in the previous call to addForce().
/
/ The derivative should be directly derived from the computations
/ done by addForce. Any forces neglected in addDForce will be integrated
/ explicitly (i.e. using its value at the beginning of the timestep).
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ df += kFactor K dx + bFactor B dx $
/
/ This method must be implemented by the component, and is usually called
/ by the generic PairInteractionForceField::addDForce() method.
/
/ To support old components that implement the deprecated addForce method
/ without scalar coefficients, it defaults to using a temporaty vector to
/ compute $ K dx $ and then manually scaling all values by kFactor."
      end

      operation 239024 "getPotentialEnergy"
	abstract const cpp_virtual public explicit_return_type "double"
	nparams 3
	  param in name "x1" type class_ref 169776 // DataVecCoord
	  param in name "x2" type class_ref 169776 // DataVecCoord
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ @deprecated
virtual void addDForce(VecDeriv& df1, VecDeriv& df2, const VecDeriv& dx1, const VecDeriv& dx2, double kFactor, double /*bFactor*/);
/ Compute the force derivative given a small displacement from the
/ position and velocity used in the previous call to addForce().
/
/ The derivative should be directly derived from the computations
/ done by addForce. Any forces neglected in addDForce will be integrated
/ explicitly (i.e. using its value at the beginning of the timestep).
/
/ If the ForceField can be represented as a matrix, this method computes
/ $ df += K dx $
/
/ This method must be implemented by the component, and is usually called
/ by the generic PairInteractionForceField::addDForce() method.
/
/ @deprecated to more efficiently accumulate contributions from all terms
/   of the system equation, a new addDForce method allowing to pass two
/   coefficients for the stiffness and damping terms should now be used.
/ @deprecated
virtual void addDForce(VecDeriv& df1, VecDeriv& df2, const VecDeriv& dx1, const VecDeriv& dx2);
/ Get the potential energy associated to this ForceField.
/
/ Used to extimate the total energy of the system by some
/ post-stabilization techniques.
/
/ This method must be implemented by the component, and is usually called
/ by the generic ForceField::getPotentialEnergy() method."
      end

      operation 239152 "canCreate"
	stereotype "template"
	class_operation cpp_inline public explicit_return_type "bool"
	nparams 3
	  param inout name "obj" explicit_type "T"
	  param inout name "context" type class_ref 141104 // BaseContext
	  param inout name "arg" type class_ref 141232 // BaseObjectDescription
	cpp_decl "    ${comment}template<class T>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * & ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        // BUGFIX(Jeremie A.): We need to test dynamic casts with the right
        // DataTypes otherwise the factory don't know which template to
        // instanciate or make sure that the right template is used.
        // This means that InteractionForceFields in scene files
        // still need to appear after the affected objects...
        if (arg->getAttribute(\"object1\") || arg->getAttribute(\"object2\"))
        {
	  //if (!arg->getAttribute(\"template\")) //if a template is specified, the interaction forcefield can be created. If during init, no corresponding MechanicalState is found, it will be erased. It allows the saving of scenes containing PairInteractionForceField
	  //{
            //return BaseInteractionForceField::canCreate(obj, context, arg);
            if (dynamic_cast<MechanicalState<DataTypes>*>(arg->findObject(arg->getAttribute(\"object1\",\"..\"))) == NULL)
                return false; 	 
            if (dynamic_cast<MechanicalState<DataTypes>*>(arg->findObject(arg->getAttribute(\"object2\",\"..\"))) == NULL) 	 
                return false;
	  //}
        }
        else
        {
            //if (context->getMechanicalState() == NULL) return false;
            if (dynamic_cast<MechanicalState<DataTypes>*>(context->getMechanicalState()) == NULL)
                 return false;
        }
        return BaseInteractionForceField::canCreate(obj, context, arg);
    };
"
	
	
	
	
	comment "/ @deprecated
virtual double getPotentialEnergy(const VecCoord& x1, const VecCoord& x2) const;
/ @}
/ Pre-construction check method called by ObjectFactory.
/ Check that DataTypes matches the MechanicalState."
      end

      operation 239280 "create"
	stereotype "template"
	class_operation cpp_inline public explicit_return_type "void"
	nparams 3
	  param inout name "obj" explicit_type "T"
	  param inout name "context" type class_ref 141104 // BaseContext
	  param inout name "arg" type class_ref 141232 // BaseObjectDescription
	cpp_decl "    ${comment}template<class T>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * & ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
        core::behavior::BaseInteractionForceField::create(obj, context, arg);
        if (arg && (arg->getAttribute(\"object1\") || arg->getAttribute(\"object2\")))
        {	  
	  obj->_object1.setValue(arg->getAttribute(\"object1\",\"..\"));
	  obj->_object2.setValue(arg->getAttribute(\"object2\",\"..\"));
	  obj->mstate1 = dynamic_cast<MechanicalState<DataTypes>*>(arg->findObject(arg->getAttribute(\"object1\",\"..\")));
	  obj->mstate2 = dynamic_cast<MechanicalState<DataTypes>*>(arg->findObject(arg->getAttribute(\"object2\",\"..\")));
        }
        else if (context)
	{
            obj->mstate1 =
            obj->mstate2 =
                dynamic_cast<MechanicalState<DataTypes>*>(context->getMechanicalState());
        }
    };
"
	
	
	
	
	comment "/ Construction method called by ObjectFactory."
      end

      operation 239408 "getTemplateName"
	const cpp_virtual cpp_inline public explicit_return_type "std::string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        return templateName(this);
    };
"
	
	
	
	
      end

      operation 239536 "templateName"
	class_operation cpp_inline public explicit_return_type "std::string"
	nparams 1
	  param in name "" explicit_type "PairInteractionForceField<DataTypes>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return DataTypes::Name();
    };
"
	
	
	
	
      end

      attribute 146096 "_object1"
	protected explicit_type " std::string "
	stereotype "sofa::core::objectmodel::Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 146224 "_object2"
	protected explicit_type " std::string "
	stereotype "sofa::core::objectmodel::Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 146352 "mstate1"
	protected explicit_type "DataTypes"
	stereotype "MechanicalState"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 146480 "mstate2"
	protected explicit_type "DataTypes"
	stereotype "MechanicalState"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      classrelation 151856 // mask1 (<unidirectional association>)
	relation 151856 --->
	  a role_name "mask1" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 151856 // mask1 (<unidirectional association>)
	  b parent class_ref 169648 // ParticleMask
      end

      classrelation 151984 // mask2 (<unidirectional association>)
	relation 151984 --->
	  a role_name "mask2" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 151984 // mask2 (<unidirectional association>)
	  b parent class_ref 169648 // ParticleMask
      end
    end

    class 170160 "PairInteractionProjectiveConstraintSet"
      abstract visibility package 
      nformals 1
      formal name "TDataTypes" type "class" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component computing constraints between a pair of simulated body.
 *
 *  This class define the abstract API common to interaction constraints
 *  between a pair of bodies using a given type of DOFs."
      classrelation 152112 // <generalisation>
	relation 152112 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 152112 // <generalisation>
	  b parent class_ref 150320 // BaseInteractionProjectiveConstraintSet
      end

      class 170288 "DataTypes"
	visibility package stereotype "typedef" explicit_base_type "TDataTypes"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 170416 "VecCoord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 170544 "VecDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 170672 "MatrixDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::MatrixDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 170800 "Coord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 170928 "Deriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 171056 "DataVecCoord"
	visibility package stereotype "typedef" base_type class_ref 170416 // VecCoord
	cpp_decl "${comment}typedef objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 152240 // <dependency>
	  relation 152240 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 152240 // <dependency>
	    b parent class_ref 170416 // VecCoord
	end
      end

      class 171184 "DataVecDeriv"
	visibility package stereotype "typedef" base_type class_ref 170544 // VecDeriv
	cpp_decl "${comment}typedef objectmodel::Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 152368 // <dependency>
	  relation 152368 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 152368 // <dependency>
	    b parent class_ref 170544 // VecDeriv
	end
      end

      class 171312 "Real"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Real"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 171440 "ParticleMask"
	visibility package stereotype "typedef" explicit_base_type "helper::ParticleMask"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      operation 239664 "PairInteractionProjectiveConstraintSet"
	public explicit_return_type ""
	nparams 2
	  param inout name "mm1" explicit_type "MechanicalState<DataTypes>"
	    defaultvalue "NULL"
	  param inout name "mm2" explicit_type "MechanicalState<DataTypes>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, ${t1} * ${p1}${v1}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}, ${t1} * ${p1}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 239792 "~PairInteractionProjectiveConstraintSet"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      attribute 146608 "endTime"
	public explicit_type "double"
	stereotype "Data"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "/< Time when the constraint becomes inactive (-1 for infinitely active)"
      end

      operation 239920 "isActive"
	const cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 240048 "init"
	cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/< if false, the constraint does nothing"
      end

      operation 240176 "getMState1"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate1; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 240304 "getMechModel1"
	cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate1; };
"
	
	
	
	
      end

      operation 240432 "getMState2"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate2; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 240560 "getMechModel2"
	cpp_inline public return_type class_ref 150064 // BaseMechanicalState
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate2; };
"
	
	
	
	
      end

      operation 240688 "projectResponse"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "dxId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @name Vector operations
/ @{
/ Project dx to constrained space (dx models an acceleration).
/
/ This method retrieves the dx vector from the MechanicalState and call
/ the internal projectResponse(VecDeriv&,VecDeriv&) method implemented by
/ the component."
      end

      operation 240816 "projectJacobianMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "cId" type class_ref 129072 // MultiMatrixDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Project the L matrix of the Lagrange Multiplier equation system.
/
/ This method retrieves the lines of the Jacobian Matrix from the MechanicalState and call
/ the internal projectResponse(MatrixDeriv&) method implemented by
/ the component."
      end

      operation 240944 "projectVelocity"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "vId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Project v to constrained space (v models a velocity).
/
/ This method retrieves the v vector from the MechanicalState and call
/ the internal projectVelocity(VecDeriv&,VecDeriv&) method implemented by
/ the component."
      end

      operation 241072 "projectPosition"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "xId" type class_ref 128432 // MultiVecCoordId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Project x to constrained space (x models a position).
/
/ This method retrieves the x vector from the MechanicalState and call
/ the internal projectPosition(VecCoord&,VecCoord&) method implemented by
/ the component."
      end

      operation 241200 "projectResponse"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param inout name "dx1" type class_ref 171184 // DataVecDeriv
	  param inout name "dx2" type class_ref 171184 // DataVecDeriv
	  param in name "" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, const ${t2} * ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Project dx to constrained space (dx models an acceleration)."
      end
    end

    class 171568 "TParallelMultiVec"
      visibility package 
      nformals 1
      formal name "VecType vtype" type "" explicit_default_value ""
        explicit_extends ""
      nactuals 1
      actual class class_ref 166320 // TMultiVec
        rank 0 explicit_value "vtype"
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "/ Helper class providing a high-level view of underlying state vectors.
/
/ It is used to convert math-like operations to call to computation methods."
      classrelation 152496 // <realization>
	relation 152496 -_-|>
	  stereotype "bind"
	  a public
	    cpp default "${type}"
	    classrelation_ref 152496 // <realization>
	  b parent class_ref 166320 // TMultiVec
      end

      class 171696 "MyMultiVecId"
	visibility package stereotype "typedef" explicit_base_type "TMultiVecId<vtype, V_WRITE>"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 171824 "ConstMyMultiVecId"
	visibility package stereotype "typedef" explicit_base_type "TMultiVecId<vtype, V_READ>"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 171952 "AllMultiVecId"
	visibility package stereotype "typedef" explicit_base_type "TMultiVecId<V_ALL, V_WRITE>"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 172080 "ConstAllMultiVecId"
	visibility package stereotype "typedef" explicit_base_type "TMultiVecId<V_ALL, V_READ>"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      operation 241328 "TParallelMultiVec"
	cpp_inline private explicit_return_type ""
	nparams 1
	  param in name "" explicit_type "TParallelMultiVec<vtype>"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw} {};
"
	
	
	
	
	comment "/ Copy-constructor is forbidden"
      end

      operation 241456 "TParallelMultiVec"
	cpp_inline public explicit_return_type ""
	nparams 2
	  param inout name "vop" type class_ref 152624 // BaseVectorOperations
	  param in name "v" type class_ref 171696 // MyMultiVecId
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw} : sofa::core::behavior::TMultiVec<vtype>(vop, v)
	{};
"
	
	
	
	
	comment "/ Refers to a state vector with the given ID (core::VecId::position(), core::VecId::velocity(), etc)."
      end

      operation 241584 "TParallelMultiVec"
	cpp_inline public explicit_return_type ""
	nparams 1
	  param inout name "vop" type class_ref 152624 // BaseVectorOperations
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}${)}${volatile}${throw} : sofa::core::behavior::TMultiVec<vtype>(vop)
  {};
"
	
	
	
	
	comment "/ Allocate a new temporary vector with the given type (sofa::core::V_COORD or sofa::core::V_DERIV)."
      end

      operation 241712 "~TParallelMultiVec"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {
      if (this->dynamic) this->vop->v_free(this->v);
  };
"
	
	
	
	
      end

      operation 241840 "peq"
	cpp_inline public explicit_return_type "void"
	nparams 3
	  param in name "a" type class_ref 171952 // AllMultiVecId
	  param inout name "fSh" explicit_type "Shared<double>"
	  param in name "f" explicit_type "double"
	    defaultvalue "1.0"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
      this->vop->v_peq(this->v, a, fSh,f);
  };
"
	
	
	
	
      end

      operation 241968 "peq"
	cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "a" type class_ref 171952 // AllMultiVecId
	  param in name "f" explicit_type "double"
	    defaultvalue "1.0"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
      this->vop->v_peq(this->v, a, f);
  };
"
	
	
	
	
      end

      operation 242096 "meq"
	cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "a" type class_ref 171952 // AllMultiVecId
	  param inout name "fSh" explicit_type "Shared<double>"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
      this->vop->v_meq(this->v, a, fSh);
  };
"
	
	
	
	
      end

      operation 242224 "dot"
	cpp_inline public explicit_return_type "void"
	nparams 2
	  param inout name "r" explicit_type "Shared<double>"
	  param in name "a" type class_ref 171696 // MyMultiVecId
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
      this->vop->v_dot(r,this->v, a);
  };
"
	
	
	
	
      end

      operation 242352 "print"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
      this->vop->print(this->v,std::cerr);
  };
"
	
	
	
	
      end

      operation 242480 "operator MyMultiVecId"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${name}${(}${)}${const}${volatile}${throw}${abstract} {	return this->v ; };
"
	
	
	
	
      end

      operation 242608 "operator ConstMyMultiVecId"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${name}${(}${)}${const}${volatile}${throw}${abstract} { return this->v ; };
"
	
	
	
	
      end

      operation 242736 "operator AllMultiVecId"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${name}${(}${)}${const}${volatile}${throw}${abstract} {	return this->v ; };
"
	
	
	
	
      end

      operation 242864 "operator ConstAllMultiVecId"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${name}${(}${)}${const}${volatile}${throw}${abstract} { return this->v ; };
"
	
	
	
	
      end
    end

    class 172208 "ParallelMultiVecCoord"
      visibility package stereotype "typedef" explicit_base_type "TParallelMultiVec<V_COORD>"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
    end

    class 172336 "ParallelMultiVecDeriv"
      visibility package stereotype "typedef" explicit_base_type "TParallelMultiVec<V_DERIV>"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
    end

    class 172464 "ParallelMultiVecMatrixDeriv"
      visibility package stereotype "typedef" explicit_base_type "TParallelMultiVec<V_MATDERIV>"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
    end

    class 172592 "ProjectiveConstraintSet"
      abstract visibility package 
      nformals 1
      formal name "DataTypes" type "class" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "*
 *  \\brief Component computing constraints within a simulated body.
 *
 *  This class define the abstract API common to constraints using a given type
 *  of DOFs.
 *  A ProjectiveConstraintSet computes constraints applied to one simulated body given its
 *  current position and velocity.
 *"
      classrelation 152624 // <generalisation>
	relation 152624 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 152624 // <generalisation>
	  b parent class_ref 150448 // BaseProjectiveConstraintSet
      end

      class 172720 "Real"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Real"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 172848 "VecCoord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecCoord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 172976 "VecDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::VecDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 173104 "MatrixDeriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::MatrixDeriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 173232 "Coord"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Coord"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 173360 "Deriv"
	visibility package stereotype "typedef" explicit_base_type "DataTypes::Deriv"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 173488 "DataVecCoord"
	visibility package stereotype "typedef" base_type class_ref 172848 // VecCoord
	cpp_decl "${comment}typedef Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 152752 // <dependency>
	  relation 152752 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 152752 // <dependency>
	    b parent class_ref 172848 // VecCoord
	end
      end

      class 173616 "DataVecDeriv"
	visibility package stereotype "typedef" base_type class_ref 172976 // VecDeriv
	cpp_decl "${comment}typedef Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 152880 // <dependency>
	  relation 152880 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 152880 // <dependency>
	    b parent class_ref 172976 // VecDeriv
	end
      end

      class 173744 "DataMatrixDeriv"
	visibility package stereotype "typedef" base_type class_ref 173104 // MatrixDeriv
	cpp_decl "${comment}typedef Data<${type}> ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 153008 // <dependency>
	  relation 153008 -_->
	    a default
	      cpp default "#include in source"
	      classrelation_ref 153008 // <dependency>
	    b parent class_ref 173104 // MatrixDeriv
	end
      end

      class 173872 "MatrixDerivRowIterator"
	visibility package stereotype "typedef" explicit_base_type "MatrixDeriv::RowIterator"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      class 174000 "MatrixDerivRowType"
	visibility package stereotype "typedef" explicit_base_type "MatrixDeriv::RowType"
	cpp_decl "${comment}typedef  typename ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
      end

      operation 242992 "ProjectiveConstraintSet"
	public explicit_return_type ""
	nparams 1
	  param inout name "mm" explicit_type "MechanicalState<DataTypes>"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      operation 243120 "~ProjectiveConstraintSet"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
      end

      classrelation 153136 // endTime (<directional composition>)
	relation 153136 *-->
	  stereotype "Data"
	  a role_name "endTime" public
	    comment "/< Time when the constraint becomes inactive (-1 for infinitely active)"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	    classrelation_ref 153136 // endTime (<directional composition>)
	  b parent class_ref 172720 // Real
      end

      operation 243248 "isActive"
	const cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
      end

      operation 243376 "init"
	cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/< if false, the constraint does nothing"
      end

      operation 243504 "getMState"
	cpp_inline public explicit_return_type "MechanicalState<DataTypes>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return mstate; };
"
	
	
	
	
	comment "/ Retrieve the associated MechanicalState"
      end

      operation 243632 "projectResponse"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "dxId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ @name Vector operations
/ @{
/ Project dx to constrained space (dx models an acceleration).
/
/ This method retrieves the dxId vector from the MechanicalState and call
/ the internal projectResponse(VecDeriv&) method implemented by
/ the component."
      end

      operation 243760 "projectJacobianMatrix"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "cId" type class_ref 129072 // MultiMatrixDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Project the L matrix of the Lagrange Multiplier equation system.
/
/ This method retrieves the lines of the Jacobian Matrix from the MechanicalState and call
/ the internal projectResponse(MatrixDeriv&) method implemented by
/ the component."
      end

      operation 243888 "projectVelocity"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "vId" type class_ref 128816 // MultiVecDerivId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Project v to constrained space (v models a velocity).
/
/ This method retrieves the vId vector from the MechanicalState and call
/ the internal projectVelocity(VecDeriv&) method implemented by
/ the component."
      end

      operation 244016 "projectPosition"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "xId" type class_ref 128432 // MultiVecCoordId
	  param in name "mparams" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "/ Project x to constrained space (x models a position).
/
/ This method retrieves the xId vector from the MechanicalState and call
/ the internal projectPosition(VecCoord&) method implemented by
/ the component."
      end

      operation 244144 "projectResponse"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 2
	  param inout name "dx" type class_ref 173616 // DataVecDeriv
	  param in name "" type class_ref 128688 // MechanicalParams
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "/ Project dx to constrained space (dx models an acceleration).
/
/ This method must be implemented by the component, and is usually called
/ by the generic ProjectiveConstraintSet::projectResponse() method."
      end
    end
  end

  deploymentview 128176 "behavior"
    //deployment diagram settings
    package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
    draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
    artifact 130992 "BaseConstraint"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 147632 // ConstraintResolution
	class_ref 147760 // BaseConstraint
      end
    end

    artifact 131120 "BaseConstraintCorrection"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 149424 // typedef7
	class_ref 149296 // BaseConstraintCorrection
      end
    end

    artifact 131248 "BaseConstraintSet"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 147888 // BaseConstraintSet
      end
    end

    artifact 131376 "BaseController"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 149552 // BaseController
      end
    end

    artifact 131504 "BaseForceField"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 149680 // BaseForceField
      end
    end

    artifact 131632 "BaseInteractionConstraint"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 149936 // BaseInteractionConstraint
      end
    end

    artifact 131760 "BaseInteractionForceField"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 150192 // BaseInteractionForceField
      end
    end

    artifact 131888 "BaseInteractionProjectiveConstraintSet"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 150320 // BaseInteractionProjectiveConstraintSet
      end
    end

    artifact 132016 "BaseLMConstraint"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 150576 // ConstraintEquation
	class_ref 150704 // ConstraintGroup
	class_ref 151216 // BaseLMConstraint
      end
    end

    artifact 132144 "BaseMass"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 151472 // BaseMass
      end
    end

    artifact 132272 "BaseMechanicalState"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 150064 // BaseMechanicalState
      end
    end

    artifact 132400 "BaseProjectiveConstraintSet"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 150448 // BaseProjectiveConstraintSet
      end
    end

    artifact 132528 "BaseVectorOperations"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 152624 // BaseVectorOperations
      end
    end

    artifact 132656 "Constraint"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 152752 // Constraint
      end
    end

    artifact 132784 "ConstraintSolver"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 154160 // ConstraintSolver
      end
    end

    artifact 132912 "ForceField"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 154416 // ForceField
      end
    end

    artifact 133040 "LinearSolver"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 155440 // LinearSolver
      end
    end

    artifact 133168 "LMConstraint"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 155568 // LMConstraint
      end
    end

    artifact 133296 "Mass"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 158512 // Mass
      end
    end

    artifact 133424 "MasterSolver"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 159536 // MasterSolver
      end
    end

    artifact 133552 "MechanicalState"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 154032 // MechanicalState
      end
    end

    artifact 133680 "MixedInteractionConstraint"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 160688 // MixedInteractionConstraint
      end
    end

    artifact 133808 "MixedInteractionForceField"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 163248 // MixedInteractionForceField
      end
    end

    artifact 133936 "MultiMatrix"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 165552 // MechanicalMatrix
	class_ref 165808 // MultiMatrix
      end
    end

    artifact 134064 "MultiMatrixAccessor"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 149808 // MultiMatrixAccessor
      end
    end

    artifact 134192 "MultiVec"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 166320 // TMultiVec
	class_ref 166960 // MultiVecCoord
	class_ref 167088 // MultiVecDeriv
	class_ref 167216 // MultiVecMatrixDeriv
      end
    end

    artifact 134320 "OdeSolver"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 167344 // OdeSolver
      end
    end

    artifact 134448 "PairInteractionConstraint"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 167472 // PairInteractionConstraint
      end
    end

    artifact 134576 "PairInteractionForceField"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 168880 // PairInteractionForceField
      end
    end

    artifact 134704 "PairInteractionProjectiveConstraintSet"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 170160 // PairInteractionProjectiveConstraintSet
      end
    end

    artifact 134832 "ParallelMultiVec"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 171568 // TParallelMultiVec
	class_ref 172208 // ParallelMultiVecCoord
	class_ref 172336 // ParallelMultiVecDeriv
	class_ref 172464 // ParallelMultiVecMatrixDeriv
      end
    end

    artifact 134960 "ProjectiveConstraintSet"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 172592 // ProjectiveConstraintSet
      end
    end
  end
end
